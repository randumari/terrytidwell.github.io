<!DOCTYPE html>
<html>
<head>
    <title>Chirality</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body bgcolor="#000000">
<canvas style = 'position: absolute; left: 0px; top: 0px;' id="canvas" width="1024" height="800"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/buzz/1.1.10/buzz.min.js" type="text/javascript"></script>
<script src="../gameEngine/engine.js" type="text/javascript"></script>
    
<script>
//##########################################################################
// The game
//

var g_font;
var PHI = 1.61803398875;
var INVERSE_PHI = 0.61803398875;

//--------------------------------------------------------------------------
const Util = {

    //----------------------------------------------------------------------
    forEach: function (obj, fn)
    {
        var key;
        for (key in obj)
        {
            if (obj.hasOwnProperty(key))
            {
                fn(obj[key]);
            }
        }
    },

    //----------------------------------------------------------------------
    randomItem: function (arr)
    {
        return arr[Math.floor(Math.random() * arr.length)];
    },

    //----------------------------------------------------------------------
    shuffle: function (arr)
    {
        var current_index = arr.length, temp, random_index;
        while (0 != current_index)
        {
            // Pick a remaining element.
            random_index = Math.floor(Math.random() * current_index);
            current_index -= 1;

            // And swap it with the current element.
            temp = arr[current_index];
            arr[current_index] = arr[random_index];
            arr[random_index] = temp;
        }
        return arr;
    }
};

//##########################################################################

var PaintLevelEnum = 
{
  BG: 0,
  FLOOR: 1,
  LOWER: 2,
  ENTITIES: 3,
};

//##########################################################################

const Logo = {
  init: function (jut)
  {
    this.jut = jut;
  },
  
  reset: function ()
  {
    this.loadTimer = 0;
    this.textTimerLimit = 40;
    this.textTimer = 0;
    this.textFadeInTimerLimit = 100;
    this.textFadeInTimer = 0;
    this.cursorTimer = 0;
    this.scanline=0;
    this.polarity = 1;
    this.bounce=30;
  },
  
  handleTimeStep: function ()
  {
    if (this.loadTimer < 99)
    {
      this.loadTimer+=1;
    }
    else
    {
      this.polarity = -10;
      this.textFadeInTimer += this.polarity
    }

    if (this.textTimer < this.textTimerLimit)
    {
      this.textTimer++;
    }
    
    
    if (this.textFadeInTimer < this.textFadeInTimerLimit)
    {
      this.textFadeInTimer += this.polarity;
      if (this.textFadeInTimer <= 0)
      {
        this.reset();
      }
    }

    this.scanline+=5;
    this.cursorTimer++;
    if (this.bounce > 0)
    {
      this.bounce-=3;
    }
    else
    {
      if (Math.random() < .01 || this.polarity < 0)
      {
        this.bounce = 30;
      }
    }
  },
  
  paint: function (canvas, ctx)
  {
   //this.otherScreen.paint();
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // paint the background
    ctx.fillStyle = "rgba(0,0,0)";
    ctx.fillRect(
      0, 0,
      canvas.width,
      canvas.height);

    var text_size = Math.round(canvas.height / 6);
    var game_over = "VelociGames";
    var jitter = Math.random() * text_size / 30 - text_size / 60;
    var text = game_over.substring(0, Math.round(this.textTimer / this.textTimerLimit * game_over.length));
      
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.shadowOffsetX = canvas.width;
    ctx.shadowOffsetY = 0;
    
    ctx.shadowColor = "rgba(0,128,0," + (this.textFadeInTimer / this.textFadeInTimerLimit) + ")";

    ctx.font = text_size * 2 + "px " + g_font;
    ctx.shadowBlur = Math.round(text_size / 4);
    
    var load_text = "" + Math.round(this.loadTimer) + "%"
    if (Math.random() < .01)
    {
      ctx.shadowColor = "rgba(0,64,0," + (this.textFadeInTimer / this.textFadeInTimerLimit) + ")";
    }
    ctx.fillText(load_text, -canvas.width + canvas.width / 2 + jitter, canvas.height / 2);
    
    ctx.font = text_size + "px " + g_font;
    ctx.textAlign = "left";
    var textWidth = ctx.measureText(text + "_").width;
    if (Math.floor(this.cursorTimer / 10) % 2)
    {
      text += "_"
    }
    else
    {
      text += " ";
    }
    var textPosition = Math.round(canvas.width / 2 - textWidth / 2);
    
    ctx.shadowColor = "rgba(0,192,0," + (this.textFadeInTimer / this.textFadeInTimerLimit) + ")";
    ctx.shadowBlur = Math.round(text_size * 2 / 3);
    ctx.fillText(text, -canvas.width + textPosition + jitter, canvas.height / 2);
    ctx.shadowBlur = Math.round(text_size / 3);
    ctx.fillText(text, -canvas.width + textPosition + jitter, canvas.height / 2);
    //ctx.shadowColor = "rgba(0,255,0," + (this.textFadeInTimer / this.textFadeInTimerLimit) + ")";
    ctx.shadowBlur = 2;
    //ctx.fillStyle = "rgba(0,0,0," + .75 * (this.textFadeInTimer / this.textFadeInTimerLimit) + ")";
    ctx.fillText(text, -canvas.width + textPosition, canvas.height / 2);
    //ctx.fillText(text, canvas.width / 2, canvas.height / 2);
    ctx.lineWidth = Math.max(1, Math.round(canvas.height/400));
    ctx.strokeStyle = "rgba(0,0,0," + .25 * (this.textFadeInTimer / this.textFadeInTimerLimit) + ")";
    if(this.scanline > canvas.height * 3 / 4)
    {
      this.scanline=canvas.height/4;
    }
    ctx.putImageData(ctx.getImageData(0,Math.round(this.scanline), canvas.width, ctx.lineWidth*2), -3, Math.round(this.scanline));
    if (this.bounce > 0)
    {
    var current_bounce = Math.random()+this.bounce - this.bounce/2;
    for(var y = 0; y < canvas.width; y+=ctx.lineWidth*2)
    {
      current_bounce += Math.random() * 20 - 10;
      ctx.putImageData(ctx.getImageData(0,y, canvas.width, ctx.lineWidth*2), current_bounce, y);
    }
    }
    
    for(var y = 0; y < canvas.height; y+=2*ctx.lineWidth)
    {
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(canvas.width,y);
      ctx.stroke();
    }
    
    /*
    for(var x = 0; x < canvas.width; x+=2*ctx.lineWidth)
    {
      ctx.beginPath();
      ctx.moveTo(x,0);
      ctx.lineTo(x,canvas.height);
      ctx.stroke();
    }
    // */
  }
};

//--------------------------------------------------------------------------
var GameScreen = {
  //----------------------------------------------------------------------
  init: function (jut)
  {
    this.jut = jut;
  },

  //----------------------------------------------------------------------
  // from Screen
  reset: function ()
  {
    //stores information about graphical layout
    this.layout = null;
    this.scanline = 0;
    this.bounce = 0;
    
    this.gamestate = 
    {
      gameEntities: []
    };
  },
  
  handleMouseDown: function(event)
  {
    if (!this.layout)
    {
      return;
    }
    
    this.mouse_event = true;
    this.mouse_x = event.offsetX;
    this.mouse_y = event.offsetY;
  },
  
  //----------------------------------------------------------------------
  // from Screen
  handleTimeStep: function ()
  {
    this.scanline+=5;
  
    for (let i = 0; i < this.gamestate.gameEntities.length; i++)
    {
      if(this.gamestate.gameEntities[i].handleTimeStep)
      {
        this.gamestate.gameEntities[i].handleTimeStep(this.gamestate);
      }
    }
    
    for (let i = this.gamestate.gameEntities.length - 1; i >= 0; i--)
    {
      if(this.gamestate.gameEntities[i].active)
      {
        if(!this.gamestate.gameEntities[i].active())
        {
          this.gamestate.gameEntities.splice(i,1);
        }
      }
    }
  },
  
  draw_panel: function (canvas, ctx, panel)
  {
    ctx.shadowOffsetX = canvas.width * 2;
    ctx.shadowColor = "rgb(0, 192, 0)";
    ctx.lineCap = "round";
    ctx.shadowBlur = 80;
    ctx.strokeRect(-canvas.width * 2 + panel.x, panel.y, panel.width, panel.height);
    ctx.shadowBlur = 40;
    ctx.strokeRect(-canvas.width * 2 + panel.x, panel.y, panel.width, panel.height);
    ctx.shadowBlur = 2;
    ctx.strokeRect(-canvas.width * 2 + panel.x, panel.y, panel.width, panel.height);
    ctx.shadowBlur = 0;
  },
  
  //----------------------------------------------------------------------
  // from Screen
  paint: function (canvas, ctx)
  {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
   
    // paint the background
    ctx.fillStyle = "rgb(0, 0, 0)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.lineWidth = canvas.width / 200;
    
    if (this.layout === null)
    {
      this.layout = {};
    }
    var height = canvas.height - 2 * ctx.lineWidth;
    var width = canvas.width - 2 * ctx.lineWidth;
    this.layout.left_panel = {x : ctx.lineWidth, y:  ctx.lineWidth, width: Math.round(width/4), height: Math.round(height * 2 / 3)};
    this.layout.right_panel = {x : Math.round(width/4) + ctx.lineWidth, y: ctx.lineWidth, width: Math.round(width * 3 / 4), height: Math.round(height * 2 / 3)};
    this.layout.bottom_panel = {x : ctx.lineWidth, y: Math.round(height * 2 / 3) + ctx.lineWidth, width: width, height: Math.round(height / 3)};
    
    this.draw_panel(canvas, ctx, this.layout.left_panel);
    this.draw_panel(canvas, ctx, this.layout.right_panel);
    this.draw_panel(canvas, ctx, this.layout.bottom_panel);
    
    ctx.lineWidth = Math.max(1, Math.round(canvas.height/400));
    ctx.strokeStyle = "rgba(0,0,0,.25)";
    if(this.scanline > canvas.height)
    {
      this.scanline=0;
    }
    ctx.putImageData(ctx.getImageData(0,Math.round(this.scanline), canvas.width, ctx.lineWidth*2), -3, Math.round(this.scanline));
    if (this.bounce > 0)
    {
      var current_bounce = Math.random()+this.bounce - this.bounce/2;
      for(var y = 0; y < canvas.width; y+=ctx.lineWidth*2)
      {
        current_bounce += Math.random() * 20 - 10;
        ctx.putImageData(ctx.getImageData(0,y, canvas.width, ctx.lineWidth*2), current_bounce, y);
      }
    }
    
    for(var y = 0; y < canvas.height; y+=2*ctx.lineWidth)
    {
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(canvas.width,y);
      ctx.stroke();
    }
    
    //
    this.gamestate.gameEntities.sort(function(a,b){
      var a_lvl = 0;
      var b_lvl = 0;
      if(a.paintLevel)
      {
        a_lvl = a.paintLevel();
      }
      if(b.paintLevel)
      {
        b_lvl = b.paintLevel();
      }
      return a_lvl - b_lvl;
    });
    
    for (let i = 0; i < this.gamestate.gameEntities.length; i++)
    {
      if (this.gamestate.gameEntities[i].paint)
      {
        this.gamestate.gameEntities[i].paint(this.gamestate,this.layout,canvas,ctx);
      }
    }
  }
};

var GlobalResources =
{
  audio_components : {},
  graphic_components : {}
};

var init = function()
{
  g_font = "Lucida Console";
  var jut = createJutGameEngine(document.getElementById("canvas"));
  
  /*
  GlobalResources.audio_components.m_bg = jut.loadAudio("Assets/Sound/CrunkKnight.mp3");
  GlobalResources.audio_components.m_move = jut.loadAudio("Assets/Sound/Bounce-SoundBible.com-12678623.mp3");
  GlobalResources.graphic_components.m_pieces = jut.loadImage("Assets/Graphics/Chess_pieces.png");
  GlobalResources.graphic_components.m_gold = jut.loadImage("Assets/Graphics/coin_gold.png");
  GlobalResources.graphic_components.key = jut.loadImage("Assets/Graphics/key2.png");
  GlobalResources.graphic_components.lock = jut.loadImage("Assets/Graphics/locked.png");
  */
  
  jut.setMaintainAspectRatioMode(4/3);
  jut.addTitleScreen(GameScreen);
  GameScreen.init(jut);
  Logo.init(jut);
  jut.init();
  
}

// launch the game once the document is fully loaded
window.addEventListener("load", init);

</script>
</body>
</html>

