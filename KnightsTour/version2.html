<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body bgcolor="#000000">
<canvas style = 'position: absolute; left: 0px; top: 0px;' id="canvas" width="1024" height="800"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/buzz/1.1.10/buzz.min.js" type="text/javascript"></script>
<script src="../gameEngine/engine.js" type="text/javascript"></script>
<script src="maps.js" type="text/javascript"></script>

    
<script>
//##########################################################################
// The game
//

var PHI = 1.61803398875;
var INVERSE_PHI = 0.61803398875;

//--------------------------------------------------------------------------
const Util = {

    //----------------------------------------------------------------------
    forEach: function (obj, fn)
    {
        var key;
        for (key in obj)
        {
            if (obj.hasOwnProperty(key))
            {
                fn(obj[key]);
            }
        }
    },

    //----------------------------------------------------------------------
    randomItem: function (arr)
    {
        return arr[Math.floor(Math.random() * arr.length)];
    },

    //----------------------------------------------------------------------
    shuffle: function (arr)
    {
        var current_index = arr.length, temp, random_index;
        while (0 != current_index)
        {
            // Pick a remaining element.
            random_index = Math.floor(Math.random() * current_index);
            current_index -= 1;

            // And swap it with the current element.
            temp = arr[current_index];
            arr[current_index] = arr[random_index];
            arr[random_index] = temp;
        }
        return arr;
    }
};

//##########################################################################

var PaintLevelEnum = 
{
  BG: 0,
  FLOOR: 1,
  LOWER: 2,
  ENTITIES: 3,
};

const MinionSpawn = function (x, y, minion)
{
  this.m_pos = [x,y],
  this.m_timer = 0,
  this.m_state = 0,
  this.WARM_UP_DURATION = 30,
  this.COOL_DOWN_DURATION = 3,
  this.minion = minion;
      
  this.handleTimeStep = function (gamestate)
  {
    this.m_timer++;
    if(this.m_state == 0)
    {
      if(this.m_timer >= this.WARM_UP_DURATION)
      {
        gamestate.gameEntities.push(this.minion);
        this.m_timer = 0;
        this.m_state = 1;
      }
    }
  }
  
  this.paintLevel = function()
  {
    return PaintLevelEnum.ENTITIES + (this.m_pos[1]) * 1000;
  };
  
  this.paint = function(gamestate, layout, canvas, ctx)
  {
    var alpha = (this.m_timer / this.WARM_UP_DURATION) + (Math.random() - .5) * .2;
    
    if(this.m_state == 1)
    {
      alpha = 1 - (this.m_timer / this.COOL_DOWN_DURATION);
    }
    if(this.m_state == 0)
    {
      ctx.globalAlpha = alpha * alpha * alpha;
      this.minion.paint(gamestate, layout, canvas, ctx);
      ctx.globalAlpha = 1;
    }
    ctx.fillStyle = "rgba(255,255,255,"+.05*alpha+")";
    ctx.strokeStyle = ctx.fillStyle;

    for(var x = 0.1; x < .9; x*=1.05)
    {
      
      var width = layout.tile_width * alpha * x;
      ctx.lineCap = "round";
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(
        layout.left(this.m_pos[0] + .5),
        -1 * layout.tile_height);
      ctx.lineTo(
        layout.left(this.m_pos[0] + .5),
        layout.top(this.m_pos[1] + .5), - width * .10);
      ctx.stroke();
      /*
      g_ctx.fillRect(
        (this.m_pos[0] + .5) * this.m_layout.m_cell_width - (width / 2),
        0,
        width,
        (this.m_pos[1] + .75) * this.m_layout.m_cell_height - width
      );
      */
      var cx = layout.left(this.m_pos[0] + .5);
      var cy = layout.top(this.m_pos[1] + .5);
      var rx = width/2;
      var ry = width/4;
      ctx.save(); // save state
      ctx.beginPath();

      ctx.translate(cx-rx, cy-ry);
      ctx.scale(rx, ry);
      ctx.arc(1, 1, 1, 0, 2 * Math.PI, false);

      ctx.restore(); // restore to original state
      ctx.fill();
    }

    if(this.m_state == 2)
    {
      ctx.globalAlpha = alpha * alpha * alpha;
      this.minion.paint(gamestate, layout, canvas, ctx);
      ctx.globalAlpha = 1;
    }
  }

  this.active = function()
  {
    return this.m_state != 1 || this.m_timer < this.COOL_DOWN_DURATION;
  };
};

const FlameFountain = function (x, y)
{
  this.x = x;
  this.y = y;
  this.attack = new Attack(x,y,0,0);
  this.m_timer = 25;
  this.m_active = true;
  
  this.handleTimeStep = function(gamestate)
  {
    this.m_timer--
    if(this.m_timer === 0)
    {
      gamestate.gameEntities.push(new FlameWave(this.x, this.y, gamestate));
      this.m_timer = 100;
    }
  }
  
  this.paintLevel = function()
  {
    return PaintLevelEnum.LOWER + this.y * 1000;
  }
  
  this.paint = function(gamestate, layout, canvas, ctx)
  {
    if(this.m_timer < 25 && this.m_timer % 2 == 0)
    {
      this.attack.paint(gamestate, layout, canvas, ctx);
    }
  }
  
  this.active = function()
  {
    return this.m_active;
  }
}

const FlameWave = function (x,y,gamestate)
{
  this.m_pos = [x,y],
  this.m_width = 0,
  this.m_timer = 0,
  this.FLAME_DURATION = 120,
  this.FLAME_WIDEN_TIME = 10,
  this.attacks = [new Attack(x,y,0,0)];
  gamestate.gameEntities.push(this.attacks[0]);
        
  this.handleTimeStep = function (gamestate)
  {
    this.m_timer++;
    if((this.m_timer % this.FLAME_WIDEN_TIME) == 0)
    {
      for (let i = 0; i < this.attacks.length; i++)
      {
        this.attacks[i].m_active = false;
      }
      this.attacks = [];
      this.m_width++;
      for (let i = -1 * this.m_width; i <= this.m_width; i++)
      {
        let j = this.m_width - Math.abs(i);
        if(x+i >= 2 && x+i <= 9 && y+j >= 2 && y+j <= 9)
        {
          let attack = new Attack(x+i, y+j, i, j);
          this.attacks.push(attack);
          gamestate.gameEntities.push(attack);
        }
        if (0 !== j)
        {
          if(x+i >= 2 && x+i <= 9 && y-j >= 2 && y-j <= 9)
          {
            let attack = new Attack(x+i, y-j, i, -1 * j);
            this.attacks.push(attack);
            gamestate.gameEntities.push(attack);
          }
        }
      }
    }
  }
  this.active = function()
  {
    return this.attacks.length !== 0;
  };
};

const Sparkle = function (x, y){
  this.LIFETIME = 30;
  this.pixel_pos = [0,0];
  this.pos = [x,y];

  //initialization continued below
  this.reset = function()
  {
    //all these numbers were scaled to a grid_size of 10
    this.m_timer = 0;
    this.pixel_pos[0] = Math.random();// * this.m_layout.m_cell_width;
    this.pixel_pos[1] = Math.random() * 2;// * this.m_layout.m_cell_height;
    this.alpha = Math.random();
    //this.plane = Math.floor(2 * Math.random());
    this.rise_rate = Math.random() / 40; // layout.tile_width/5;
    this.size = Math.random() * .0625 + .025; //2 to 6
  }
  
  //end initialization
  this.reset();
  
  this.handleTimeStep = function (gamestate)
  {
    this.m_timer++;
    if(this.m_timer >= this.LIFETIME)
    {
      if(Math.random() < .1)
      {
        this.reset();
      }
    }
    this.alpha+=(Math.random()-.5)*.05;
    this.pixel_pos[1] -= this.rise_rate;
    this.pixel_pos[0] += Math.random() * .025 - .0125;    
  }
  
  this.paintLevel = function()
  {
    return PaintLevelEnum.ENTITIES + (this.pos[1] + this.pixel_pos[1] + .5) * 1000;
  };
  
  this.paint = function(gamestate, layout, canvas, ctx)
  {
    //g_ctx.globalAlpha = this.m_timer/this.LIFETIME;
    ctx.fillStyle="rgba(255,255,255,"+this.alpha+")"
    ctx.beginPath();
    ctx.arc(
      layout.left(this.pos[0] + this.pixel_pos[0]),
      layout.top(this.pos[1] - 2 + this.pixel_pos[1]),
      layout.tile_width * (this.size +  Math.random() * .025 - .0125),0,2*Math.PI);
    ctx.fill();
  }
}

const Pawn = function (x,y){
  this.x = x;
  this.y = y;
  this.m_vel = [-1,-1];
  this.m_invincible = false;
  this.m_invincible_timer = 0;
  this.m_state_timer = 0;
  this.m_pushed = false;
  this.m_attack_pos = [8,8];
  this.m_move_flip_flop = 0;
  this.m_health = 2;
  this.offset_x = 0;
  this.offset_y = 0;
  this.attack = new Attack(8,8,-1,-1);
  
  this.INVINCIBLE_TIME = 50,
  this.STUNNED_TIME = 40,
  this.ATTACK_TIME = 16;
  this.MOVE_TIME = 4;
  this.DELAY_BEFORE_MOVE = 12;
  this.ATTACK_DELAY = 8;
  
  //state machine
  this.PREMOVE = 0,
  this.MOVE = 1,
  this.ATTACK = 2,
  this.STUNNED = 3,
  this.m_state = this.PREMOVE,
  
  this.handleTimeStep = function (gamestate)
  {
    if(this.m_invincible)
    {
      this.m_invincible_timer++;
      if(this.m_invincible_timer >= this.INVINCIBLE_TIME)
      {
        this.m_invincible = false;
        this.m_invincible_timer = 0;
      }
    }
    var move_me = false;
    var delta_x = gamestate.player.x - this.x;
    var delta_y = gamestate.player.y - this.y;
    
    this.m_state_timer++;
    
    if(this.m_state != this.MOVE)
    {
      this.offset_x = 0;
      this.offset_y = 0;
    }
    
    if(this.m_state != this.ATTACK)
    {
      this.attack.m_active = false;
    }
    
    if(this.m_state == this.ATTACK && this.m_state_timer >= this.ATTACK_TIME)
    {
      this.m_state_timer = 0;
      this.m_state = this.PREMOVE;
      return;
    }
    
    if(this.m_state == this.PREMOVE && this.m_state_timer >= this.DELAY_BEFORE_MOVE)
    {
      if(Math.abs(delta_x) + Math.abs(delta_y) == 2 &&
        delta_x != 0 &&
        delta_y != 0)
      {
        this.m_state = this.ATTACK;
        this.m_state_timer = 0;
        this.m_attack_pos[0] = gamestate.player.x;
        this.m_attack_pos[1] = gamestate.player.y;
        this.attack.x = this.m_attack_pos[0];
        this.attack.y = this.m_attack_pos[1];
        this.attack.dx = delta_x;
        this.attack.dy = delta_y;
        this.attack.m_active = true;
        gamestate.gameEntities.push(this.attack);
        return;
      }
      else
      {
        this.m_state = this.MOVE;
        this.m_state_timer = 0;
        this.m_vel[0] = 1; 
        if(delta_x < 0 || (delta_x == 0 && Math.floor(Math.random()*2) == 0))
        {
          this.m_vel[0] = -1; 
        }
        this.m_vel[1] = 1; 
        if(delta_y < 0 || (delta_y == 0 && Math.floor(Math.random()*2) == 0))
        {
          this.m_vel[1] = -1; 
        }
        if(Math.abs(delta_x) + Math.abs(delta_y) < 2)
        {
          this.m_vel[0] *= -1;
          this.m_vel[1] *= -1;
        }
        if(Math.random() < .80)
        {
          this.m_move_flip_flop = (this.m_move_flip_flop + 1) % 2;
        }
        var potential_moves;
        if (this.m_move_flip_flop == 0)
        {
          //preferentially prefer vertical
          potential_moves = [[0,this.m_vel[1]],[0,-1 *this.m_vel[1]],[this.m_vel[0],0],[-1 * this.m_vel[0],0]];
        }
        else
        {
          //preferentially prefer horizontal
          potential_moves = [[this.m_vel[0],0],[-1 * this.m_vel[0],0],[0,this.m_vel[1]],[0,-1 *this.m_vel[1]]];
        }
        for(let p = 0; p < potential_moves.length; p++)
        {
          if(gamestate.board[this.x+potential_moves[p][0]][this.y+potential_moves[p][1]].solid)
          {
            this.m_vel[0] = potential_moves[p][0];
            this.m_vel[1] = potential_moves[p][1];
            break;
          }
        }
        return;
      }
    }
    
    if(this.m_state == this.MOVE)
    {
      if(this.m_state_timer == Math.round(this.MOVE_TIME / 2))
      {
        move_me = true;
      }
      var ratio = this.m_state_timer / this.MOVE_TIME;
      if(this.m_state_timer >= Math.round(this.MOVE_TIME / 2))
      {
        ratio = ratio - 1;
      }
      this.offset_x = this.m_vel[0] * ratio;
      this.offset_y = this.m_vel[1] * ratio;
      if(this.m_state_timer >= this.MOVE_TIME)
      {
        this.m_state_timer = 0;
        this.m_state = this.PREMOVE;
      }
    }
    if(this.m_state == this.STUNNED && this.m_state_timer >= this.STUNNED_TIME)
    {
      this.m_state = this.PREMOVE;
      this.m_state_timer = 0;
    }
    if(this.m_pushed)
    {
      this.m_vel[0] = 0;
      this.m_vel[1] = 0;
      var potential_directions = Util.shuffle([[1,0],[0,1],[-1,0],[0,-1]]);
      for(p in potential_directions)
      {
        if(gamestate.board[this.x+potential_directions[p][0]][this.y+potential_directions[p][1]].solid)
        {
          this.m_vel[0] = potential_directions[p][0];
          this.m_vel[1] = potential_directions[p][1];
          break;
        }
      }
      move_me = true;
      this.m_pushed = false;
    }
    
    if(move_me)
    {
      this.x += this.m_vel[0];
      this.y += this.m_vel[1];
    }       
  };
  
  this.paintLevel = function()
  {
    return PaintLevelEnum.ENTITIES + (this.y + this.offset_y + .5) * 1000;
  };
  
  this.paint = function(gamestate, layout, canvas, ctx)
  {
    if(this.m_invincible && this.m_invincible_timer % 2 == 0)
    {
      return;
    }
    
    ctx.drawImage(
      GlobalResources.graphic_components.m_pieces,
      536,
      15,
      100,
      250,
      layout.left(this.x + this.offset_x),
      layout.top(this.y + this.offset_y + 1)
        - Math.floor(2.5 * layout.tile_width),
      layout.tile_width,
      Math.floor(2.5 * layout.tile_width)
    );
  };
  
  this.handlePlayerCollision = function(x, y, gamestate)
  {
    if(this.m_state == this.ATTACK)
    {
      if(x == this.m_attack_pos[0] && y == this.m_attack_pos[1])
      {
        delta_x = 1;
        if(this.x > x)
        {
          delta_x = -1;
        }
        delta_y = 1;
        if(this.y > y)
        {
          delta_y = -1;
        }
        gamestate.player.handleDamage(delta_x, delta_y);
      }
    }
    
    if(!this.m_invincible)
    {
      if(x == this.x && y == this.y)
      {
        gamestate.player.handleDamage(this.m_vel[0], this.m_vel[1]);
      }
    }
  };
  
  this.handlePlayerAttack = function(x,y)
  {
    if(x != this.x || y != this.y)
    {
      return;
    }
  
    if(this.m_invincible)
    {
      return;
    }
    
    this.m_state = this.STUNNED;
    this.m_state_timer = 0;
    this.m_invincible = true;
    this.m_invincible_timer = 0;
    this.m_pushed = true;
    this.m_health--;
    if(this.m_health <= 0)
    {
      this.attack.m_active = false;
    }
  }
  
  this.active = function()
  {
    return this.m_health > 0;
  }
};

var TimerLoop = function(initial_offset)
{
  this.ttl = initial_offset;
  this.state = -1;
  this.states = []
  this.addState = function(max_ttl, entry_function, warning_function, exit_function)
  {
    this.states.push({max_ttl: max_ttl, entry_function: entry_function, warning_function: warning_function, exit_function: exit_function});
  }
  
  this.handleTimeStep = function(gamestate)
  {
    if(this.ttl > 0)
    {
      this.ttl--;
    }
    else if (this.ttl == 0)
    {
      if(this.states[this.state] && this.states[this.state].exit_function)
      {
        this.states[this.state].exit_function(gamestate);
      }
      this.state++;
      if(this.states.length <= this.state)
      {
        this.state = 0;
      }
      if(this.states[this.state] && this.states[this.state].entry_function)
      {
        this.states[this.state].entry_function(gamestate);
      }
      this.ttl = this.states[this.state].max_ttl;
    }
    
    if (this.ttl < 25 && this.states[this.state] && this.states[this.state].warning_function)
    {
      this.states[this.state].warning_function(gamestate);
    }
  };
};

var Button = function(x, y, ttl, pressed_function, warning_function,
  released_function)
{
  this.x = x;
  this.y = y;
  this.reset = ttl === 0;
  this.ttl_max = ttl;
  
  this.ttl = 0;
  this.pushed = false;
  
  this.pressed_function = pressed_function;
  this.warning_function = warning_function;
  this.released_function = released_function;
  
  this.handlePlayerAttack = function(x, y, gamestate)
  {
    if (x == this.x &&
      y == this.y)
    {
      this.pushed = true;
      this.ttl = this.ttl_max;
      this.pressed_function(gamestate);
    }
  };
  
  this.handlePlayerCollision = function(x, y, gamestate)
  {
    if (x != this.x || y != this.y)
    {
      return;
    }
    
    this.pushed = true;
    this.ttl = this.ttl_max;
  };
  
  this.handleTimeStep = function(gamestate)
  {
    if (this.max_ttl === 0)
    {
      return;
    }
    if (!this.pushed)
    {
      return;
    }
    
    if (this.ttl === 0)
    {
      this.pushed = false;
      this.released_function(gamestate);
    }
    
    if (this.ttl > 0)
    {
      this.ttl--;
    }
    
    if (this.ttl > 0 && this.ttl < 25)
    {
      this.warning_function(gamestate);
    }
  };
  
  this.paintLevel = function()
  {
    return PaintLevelEnum.LOWER + this.y * 1000;
  }
  
  this.paint = function (gamestate, layout, canvas, ctx)
  {
    if(!this.pushed)
    {
      ctx.fillStyle = "rgb(192,128,128)";
      ctx.fillRect(
        layout.left(this.x + .25),
        layout.top(this.y + .125),
        layout.tile_width/2,
        layout.tile_height/2);
      ctx.fillStyle = "rgb(256,192,192)";
      ctx.fillRect(
        layout.left(this.x + .25),
        layout.top(this.y + .5),
        layout.tile_width/2,
        layout.tile_height/4);
    }
    else
    {
      ctx.fillStyle = "rgb(192,128,128)";
      ctx.fillRect(
        layout.left(this.x + .25),
        layout.top(this.y + .25),
        layout.tile_width/2,
        layout.tile_height/2);    
    }
  };
};

var Key = function(x, y)
{
  this.x = x;
  this.y = y;
  this.m_active = true;
  
  this.handlePlayerCollision = function(x, y, gamestate)
  {
    if(this.x != x || this.y != y || !this.m_active)
    {
      return;
    }
    this.m_active = false;
    gamestate.player.keys++;
  };
  
  this.paintLevel = function()
  {
    return PaintLevelEnum.LOWER + this.y * 1000;
  }
  
  this.paint = function (gamestate, layout, canvas, ctx)
  {
    ctx.drawImage(
      GlobalResources.graphic_components.key,
      0,
      0,
      512,
      1024,
      layout.left(this.x + .25),
      layout.top(this.y + .75)
        - Math.floor(.5 * layout.tile_width * 2),
      layout.tile_width * .5,
      Math.floor(.5 * layout.tile_width * 2)
    );
  };
  
  this.active = function()
  {
    return this.m_active;
  };
};

var LockPaint = function(x, y)
{
  this.x = x;
  this.y = y;
  this.m_active = true;
  
  this.paintLevel = function()
  {
    return PaintLevelEnum.LOWER + this.y * 1000;
  }
  
  this.paint = function (gamestate, layout, canvas, ctx)
  {
    ctx.fillStyle = "rgba(128,128,0,.2)";
    ctx.fillRect(
      layout.left(this.x),
      layout.top(this.y),
      layout.tile_width,
      layout.tile_height);
  };
  
  this.active = function()
  {
    return this.m_active
  };
};

var Lock = function(victory_function)
{
  this.locks = [];
  this.m_active = true;
  this.victory_function = victory_function;

  this.handlePlayerAttack = function(x, y, gamestate)
  {
    if (!this.m_active)
    {
      return;
    }
  
    for (let l = 0; l < this.locks.length; l++)
    {
      if (this.locks[l].x === x && this.locks[l].y === y)
      {
        if (gamestate.player.keys > 0)
        {
          gamestate.player.keys--;
          this.victory_function(gamestate);
          this.m_active = false;
          for (let i = 0; i < this.locks.length; i++)
          {
            this.locks[i].m_active = false;
          }
        }
      }
    }
    
  };
  
  this.active = function()
  {
    return this.m_active
  };
};

var ButtonArrayButton = function(x, y)
{
  this.x = x;
  this.y = y;
  this.pushed = false;
  
  this.paintLevel = function()
  {
    return PaintLevelEnum.LOWER + this.y * 1000;
  }
  
  this.paint = function (gamestate, layout, canvas, ctx)
  {
    if(!this.pushed)
    {
      ctx.fillStyle = "rgb(192,128,128)";
      ctx.fillRect(
        layout.left(this.x + .25),
        layout.top(this.y + .125),
        layout.tile_width/2,
        layout.tile_height/2);
      ctx.fillStyle = "rgb(256,192,192)";
      ctx.fillRect(
        layout.left(this.x + .25),
        layout.top(this.y + .5),
        layout.tile_width/2,
        layout.tile_height/4);
    }
    else
    {
      ctx.fillStyle = "rgb(192,128,128)";
      ctx.fillRect(
        layout.left(this.x + .25),
        layout.top(this.y + .25),
        layout.tile_width/2,
        layout.tile_height/2);
    }
  };
};

var ButtonArray = function(victory_function)
{
  this.buttons = [];
  this.pressed = false;
  this.victory_function = victory_function;

  this.handlePlayerAttack = function(x, y, gamestate)
  {
    if (this.pressed)
    {
      return;
    }
    var needs_reset = true;
    this.pressed = true;
    var collidided = -1;
    for (let b = 0; b < this.buttons.length; b++)
    {
      if(this.buttons[b].x === x && this.buttons[b].y === y)
      {
        collidided = b;
        if (!this.buttons[b].pushed)
        {
          needs_reset = false;
          this.buttons[b].pushed = true;
        }
      }
      if (!this.buttons[b].pushed)
      {
        this.pressed = false;
      }
    }
    
    if (needs_reset)
    {
      for (let b = 0; b < this.buttons.length; b++)
      {
        if (b !== collidided)
        {
          this.buttons[b].pushed = false;
        }
      }
    }
    
    if (this.pressed)
    {
      if(this.victory_function)
      {
        this.victory_function(gamestate);
      }
    }
  };
};

var Attack = function(x, y, dx, dy)
{
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this.m_active = true;

  this.handlePlayerCollision = function (x, y, gamestate)
  {
    if(x == this.x && y == this.y)
    {
      gamestate.player.handleDamage(dx, dy);
    }
  }
  
  this.paintLevel = function()
  {
    return PaintLevelEnum.LOWER + (this.y) * 1000;
  };
  
  this.paint = function(gamestate, layout, canvas, ctx)
  {
    ctx.fillStyle = "rgba(255,0,0,.5)";
    ctx.fillRect(
      layout.left(this.x),
      layout.top(this.y),
      layout.tile_width,
      layout.tile_height
    );
  };
  
  this.active = function()
  {
    return this.m_active;
  };
};

var FloorTile = function(x, y, solid)
{
  this.x = x;
  this.y = y;
  this.visible = solid;
  this.solid = solid;
  
  this.paintLevel = function()
  {
    return PaintLevelEnum.FLOOR + this.y * 1000;
  }
  
  this.paint = function (gamestate, layout, canvas, ctx)
  {
    if(!this.visible)
    {
      return;
    }
    
    if (((this.x + this.y)%2) == 0)
    {
      ctx.fillStyle = "rgb(128,128,128)";
    }
    else
    {
      ctx.fillStyle = "rgb(192,192,192)";
    }
    ctx.fillRect
    (
      layout.left(this.x),
      layout.top(this.y),
      layout.tile_width,
      layout.tile_height
    );
    if(gamestate.player.player_health == 0)
    {
      return;
    }
    if(x != gamestate.player.x && y != gamestate.player.y && Math.abs(x - gamestate.player.x) + Math.abs(y - gamestate.player.y) == 3)
    {
      ctx.fillStyle = "rgba(0,255,0,.2)";
      ctx.fillRect
      (
        layout.left(this.x),
        layout.top(this.y),
        layout.tile_width,
        layout.tile_height
      );
    }
  };
};

var DeathWatch = function(victory_function)
{
  this.m_active = true;
  this.children = [];
  this.victory_function = victory_function;
  
  this.addChild = function(child)
  {
    this.children.push(child);
  };
  
  this.handleTimeStep = function(gamestate)
  {
    if(!this.m_active)
    {
      return;
    }
    this.m_active = false;
    for (let c = 0; c < this.children.length; c++)
    {
      if (this.children[c].active)
      {
        if (this.children[c].active())
        {
          this.m_active = true;
        }
      }
    }
    if(!this.m_active)
    {
      if(this.victory_function)
      {
        this.victory_function(gamestate);
      }
    }
  };
  
  this.active = function()
  {
    return this.m_active;
  };
};

var RoomEnter = function(victory_function)
{
  this.m_active = true;
  this.victory_function = victory_function;
  
  this.addChild = function(child)
  {
    this.children.push(child);
  };
  
  this.handlePlayerCollision = function(x, y, gamestate)
  {
    if(!this.m_active)
    {
      return;
    }
    this.m_active = x < 2 || x > 9 || y < 2 || y > 9;
    if(!this.m_active)
    {
      if(this.victory_function)
      {
        this.victory_function(gamestate);
      }
    }
  };
  
  this.active = function()
  {
    return this.m_active;
  };
};

var Player = function(x,y)
{
  this.x = x;
  this.y = y;
  this.y_offset = 0;
  this.keys = 0;
  this.player_health = 20;
  this.player_pushed = false;
  this.player_push_x = 0;
  this.player_push_y = 0;
  this.player_stun_timer = 0;
  this.PLAYER_STUN_PERIOD = 10;
  this.PLAYER_INVINCIBLE_PERIOD = 30;
  this.player_invincible_timer = 0;
  
  this.acceptInput = function()
  {
    return this.player_stun_timer === 0 && this.y_offset === 0;
  };
  
  this.handleTimeStep = function(gamestate)
  {
    if(this.player_stun_timer > 0)
    {
      this.player_stun_timer--;
    }
    
    if(this.player_pushed)
    {
      this.player_push_x = Math.sign(this.player_push_x);
      this.player_push_y = Math.sign(this.player_push_y);
      var lookup=[
        [4,5,6],
        [3,8,7],
        [2,1,0]
      ];
      var rev_lookup=
      [
        [1,1],
        [1,0],
        [1,-1],
        [0,-1],
        [-1,-1],
        [-1,0],
        [-1,1],
        [0,1]
      ];
      var possible_moves = [];
      if (this.player_push_x == 0 && this.player_push_y == 0)
      {
        possible_moves = Util.shuffle(rev_lookup);
      }
      else
      {
        var original_pos = lookup[this.player_push_x + 1][this.player_push_y + 1];
        possible_moves.push(rev_lookup[original_pos]);
        
        for (let j = 1; j <= 3; j++)
        {
          var next_moves = 
            Util.shuffle([(original_pos + j) % 8,(original_pos + (7*j)) % 8]);
          for(let i = 0; i < next_moves.length; ++i)
          {
            possible_moves.push(rev_lookup[next_moves[i]]);
          }
        }
      }
      
      this.player_push_x = 0;
      this.player_push_y = 0;
      for (let i = 0; i < possible_moves.length; i++)
      {
        if (gamestate.board[this.x + possible_moves[i][0]][this.y + possible_moves[i][1]].solid)
        {
          this.player_push_x = possible_moves[i][0];
          this.player_push_y = possible_moves[i][1];
          break;
        }
      }
      this.player_pushed = false;
      this.x += this.player_push_x;
      this.y += this.player_push_y;
    }
    
    if(this.player_invincible_timer > 0)
    {
      this.player_invincible_timer--;
    }
  }
  
  this.handleDamage = function(delta_x, delta_y)
  {
    if(this.player_invincible_timer > 0)
    {
      return;
    }
    this.player_stun_timer = this.PLAYER_STUN_PERIOD;
    this.player_invincible_timer = this.PLAYER_INVINCIBLE_PERIOD;
    this.player_pushed = true;
    this.player_push_x = delta_x;
    this.player_push_y = delta_y;
    if(this.player_health > 0)
    {
      this.player_health--;
    }
  }

  this.paintLevel = function()
  {
    return PaintLevelEnum.ENTITIES + (this.y + .5) * 1000;
  }
  
  this.paint = function (gamestate, layout, canvas, ctx)
  {
    if (this.player_invincible_timer > 0 && this.player_invincible_timer % 2 === 0)
    {
      return;
    }
    if (this.player_health === 0)
    {
      return;
    }
    ctx.drawImage(
      GlobalResources.graphic_components.m_pieces,
      436,
      15,
      100,
      250,
      layout.left(this.x),
      layout.top(this.y + 1)
        - Math.floor(2.5 * layout.tile_width) + this.y_offset,
      layout.tile_width,
      Math.floor(layout.tile_width * 2.5)
    );
  };
};

//--------------------------------------------------------------------------
var GameScreen = {
  //----------------------------------------------------------------------
  init: function ()
  {
  },

  //----------------------------------------------------------------------
  // from Screen
  reset: function ()
  {
    Dungeon.resetDungeon();
    
    this.mouse_event = false;
    this.mouse_x = 0;
    this.mouse_y = 0;
    
    //stores information about graphical layout
    this.layout = null;

    this.gamestate = 
    {
      player : new Player(5,5),
      board : [],
      gameEntities: []
    }
    this.current_room_x = 0;
    this.current_room_y = 0;
    this.loadRoom(this.current_room_x,this.current_room_y);
  },
  
  loadRoom: function(x,y)
  {
    Dungeon.loadRoom(x,y,this.gamestate);
    return;
  },
  
  loadBoard: function(string_array)
  {
    this.gamestate.board = [];
    var dim_y = string_array.length;
    var dim_x = 0;
    for(let i = 0; i < dim_y; i++)
    {
      if(i == 0)
      {
        dim_x = string_array[i].length;
      }
      else
      {
        dim_x = Math.max(dim_x, string_array[i].length);
      }
    }
    for(let x = 0; x < dim_x; x++)
    {
      var row = [];
      for(let y = 0; y < dim_y; y++)
      {
        if (x < string_array[y].length && string_array[y][x] != '-')
        {
          var tile = new FloorTile(x,y,true)
          row.push(tile);
          this.gamestate.gameEntities.push(tile);
        }
        else
        {
          var tile = new FloorTile(x,y,false)
          row.push(tile);
          this.gamestate.gameEntities.push(tile);
        }
      }
      this.gamestate.board.push(row);
    }
  },

  handleMouseDown: function(event)
  {
    if (!this.layout)
    {
      return;
    }
    
    if (!this.gamestate.player.acceptInput())
    {
      return;
    }
    
    this.mouse_event = true;
    this.mouse_x = event.offsetX;
    this.mouse_y = event.offsetY;
  },
  
  //----------------------------------------------------------------------
  // from Screen
  handleTimeStep: function ()
  {
    if(this.mouse_event && this.layout)
    {
      this.mouse_event = false;
      var tile_x = Math.floor((this.mouse_x - this.layout.center_x)/this.layout.tile_width) + 6;
      var tile_y = Math.floor((this.mouse_y - this.layout.center_y)/this.layout.tile_height) + 6;
      if(tile_x >= 0 && tile_x <= 11 && tile_y >= 0 && tile_y <= 11)
      {
        //alert(tile_x + ", " + tile_y)
        if (this.gamestate.board[tile_x][tile_y].solid && 
          tile_x != this.gamestate.player.x && tile_y != this.gamestate.player.y &&
          Math.abs(tile_x - this.gamestate.player.x) + Math.abs(tile_y - this.gamestate.player.y) == 3)
        {
          this.gamestate.player.x = tile_x;
          this.gamestate.player.y = tile_y;
          
          for (let i = 0; i < this.gamestate.gameEntities.length; i++)
          {
            if(this.gamestate.gameEntities[i].handlePlayerAttack)
            {
              this.gamestate.gameEntities[i].handlePlayerAttack(this.gamestate.player.x, this.gamestate.player.y, this.gamestate);
            }
          }
                  
          //did we move into an exit square?
          if(this.gamestate.player.x > 9)
          {
            this.gamestate.player.x = this.gamestate.player.x - 10;
            this.current_room_x++;
            this.loadRoom(this.current_room_x,this.current_room_y);
          }
          else if(this.gamestate.player.y > 9)
          {
            this.gamestate.player.y = this.gamestate.player.y - 10;
            this.current_room_y++;
            this.loadRoom(this.current_room_x,this.current_room_y);
          }
          else if(this.gamestate.player.x < 2)
          {
            this.gamestate.player.x = this.gamestate.player.x + 10;
            this.current_room_x--;
            this.loadRoom(this.current_room_x,this.current_room_y);
          }
          else if(this.gamestate.player.y < 2)
          {
            this.gamestate.player.y = this.gamestate.player.y + 10;
            this.current_room_y--;
            this.loadRoom(this.current_room_x,this.current_room_y);
          }
        }
      }
    }
    
    for (let i = 0; i < this.gamestate.gameEntities.length; i++)
    {
      if(this.gamestate.gameEntities[i].handleTimeStep)
      {
        this.gamestate.gameEntities[i].handleTimeStep(this.gamestate);
      }
    }
    
    //collisions
    for (let i = 0; i < this.gamestate.gameEntities.length; i++)
    {
      if(this.gamestate.gameEntities[i].handlePlayerCollision)
      {
        this.gamestate.gameEntities[i].handlePlayerCollision(this.gamestate.player.x, this.gamestate.player.y, this.gamestate);
      }
    }
    
    if(!this.gamestate.board[this.gamestate.player.x][this.gamestate.player.y].solid)
    {
      if(this.gamestate.player.y_offset === 0)
      {
        this.gamestate.player.y_offset = 20;
      }
      else
      {
        this.gamestate.player.y_offset += this.gamestate.player.y_offset;
      }
      if(this.gamestate.player.y_offset > 25 * 40)
      {
        this.reset();
      }
    }
    
    var temp_entities = [];
    for (let i = 0; i < this.gamestate.gameEntities.length; i++)
    {
      if(this.gamestate.gameEntities[i].active)
      {
        if(!this.gamestate.gameEntities[i].active())
        {
          continue;
        }
      }
      temp_entities.push(this.gamestate.gameEntities[i]);
    }
    this.gamestate.gameEntities = temp_entities;
  },
  
  //----------------------------------------------------------------------
  // from Screen
  paint: function (canvas, ctx)
  {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
   
    // paint the background
    ctx.fillStyle = "rgb(0, 0, 0)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = "rgb(255,255,255)";
    
    if (this.layout === null)
    {
      this.layout = {
        left : function(x)
        {
          return Math.round((x - 6) * this.tile_width + this.center_x);
        },
        top : function(y)
        {
          return Math.round((y - 6) * this.tile_height + this.center_y);
        }
      };
    }
    this.layout.center_x = Math.round(canvas.width / 2);
    this.layout.center_y = Math.round(canvas.height / 2);
    this.layout.tile_width = Math.round(canvas.width/12);
    this.layout.tile_height = Math.round(canvas.width/24);

    this.gamestate.gameEntities.sort(function(a,b){
      var a_lvl = 0;
      var b_lvl = 0;
      if(a.paintLevel)
      {
        a_lvl = a.paintLevel();
      }
      if(b.paintLevel)
      {
        b_lvl = b.paintLevel();
      }
      return a_lvl - b_lvl;
    });
    
    for (let i = 0; i < this.gamestate.gameEntities.length; i++)
    {
      if (this.gamestate.gameEntities[i].paint)
      {
        this.gamestate.gameEntities[i].paint(this.gamestate,this.layout,canvas,ctx);
      }
    }
  }
};

var GlobalResources =
{
  audio_components : {},
  graphic_components : {}
};

var init = function()
{
  var jut = createJutGameEngine(document.getElementById("canvas"));
  
  GlobalResources.audio_components.m_bg = jut.loadAudio("Assets/Sound/CrunkKnight.mp3");
  GlobalResources.graphic_components.m_pieces = jut.loadImage("Assets/Graphics/Chess_pieces.png");
  GlobalResources.graphic_components.m_gold = jut.loadImage("Assets/Graphics/coin_gold.png");
  GlobalResources.graphic_components.key = jut.loadImage("Assets/Graphics/key2.png");
  
  jut.setMaintainAspectRatioMode(4/3);
  jut.addTitleScreen(GameScreen);
  jut.init();
}

// launch the game once the document is fully loaded
window.addEventListener("load", init);

</script>
</body>
</html>

