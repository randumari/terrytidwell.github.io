<!DOCTYPE html>
<html>
<head>
    <title>Crossword Puzzles</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/buzz/1.1.10/buzz.min.js" type="text/javascript"></script>
</head>
<canvas oncontextmenu="return false;" style = 'position: absolute; left: 0px; top: 0px;' id="canvas" width="800" height="600"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/buzz/1.1.10/buzz.min.js" type="text/javascript"></script>
<script src="../gameEngine/engine.js" type="text/javascript"></script>
<script src="puzzles.js" type="text/javascript"></script>
<script>
//##########################################################################
// The game

var g_canvas;
var g_ctx;
var g_current_screen;
var g_level;
var g_completed;
var g_leveldone;
var g_click;
var g_mainloop;

var PHI = 1.61803398875;
var INVERSE_PHI = 0.61803398875;


var GRID_SIZE = 35/600;
var MOVE_COLOR = "red";
var MOVEABLE_COLOR = "black";
var STATIC_COLOR = "lightgrey";

//--------------------------------------------------------------------------
const Util = {

    //----------------------------------------------------------------------
    forEach: function (obj, fn)
    {
        var key;
        for (key in obj)
        {
            if (obj.hasOwnProperty(key))
            {
                fn(obj[key]);
            }
        }
    },

    //----------------------------------------------------------------------
    randomItem: function (arr)
    {
        return arr[Math.floor(Math.random() * arr.length)];
    },

    //----------------------------------------------------------------------
    shuffle: function (arr)
    {
        var current_index = arr.length, temp, random_index;
        while (0 != current_index)
        {
            // Pick a remaining element.
            random_index = Math.floor(Math.random() * current_index);
            current_index -= 1;

            // And swap it with the current element.
            temp = arr[current_index];
            arr[current_index] = arr[random_index];
            arr[random_index] = temp;
        }
        return arr;
    },

    //----------------------------------------------------------------------
    loadImage: function (url, resource_tracker)
    {
        var image = new Image();
        resource_tracker.add();
        image.onload = function (event) {
            resource_tracker.onload(event);
        };
        image.src = url;
        return image;
    },

    //----------------------------------------------------------------------
    loadAudio: function (url, resource_tracker)
    {
        var audio = new buzz.sound(
          url, {
          //formats: [ "wav" ],
          preload: true,
          autoplay: false,
          loop: false
        });
        resource_tracker.add();
        audio.bindOnce("canplay", function (event) {
            resource_tracker.onload(event)
        });
        return audio;
    }
};

var TextLabelWithBoundingBox = function(text, x, y, width, color, size)
{
  
  this.x = x;
  this.y = y;
  this.size = size;
  this.height = size * text.length;
  this.width = width;
  this.inner_size = (6 * this.size/7);
  this.offset = ((this.size - this.inner_size) / 2);
  this.inner_width = this.width - this.offset * 2;
  this.inner_height = this.height - this.offset * 2;
  this.color = "black"
  this.font_size = (INVERSE_PHI * size);
  this.textLabel = [];
  for (var i = 0; i < text.length; i++)
  {
    this.textLabel.push(new TextLabel(text[i], x + this.offset + this.width/2, (y + this.size * i + this.offset + this.inner_size / 2), color, HorizontalLabelAlignEnum.CENTER, VerticalLabelBaselineEnum.MIDDLE, this.font_size));
  }
  
  this.paint = function(ctx)
  {
    //var width = this.textLabel.text_size;
    var x = Math.round(this.x * g_canvas.height);
    var y = Math.round(this.y * g_canvas.height);
    var offset = Math.round(this.offset * g_canvas.height);
    var inner_width = Math.round(this.inner_width * g_canvas.height);
    var inner_height = Math.round(this.inner_height * g_canvas.height);
    ctx.lineJoin ="round";
    ctx.lineWidth = Math.round(this.size / (10*PHI));
    ctx.fillStyle = "#f0f0f0";
    ctx.fillRect(x + offset, y + offset, inner_width, inner_height);
    ctx.strokeStyle = this.color;
    ctx.fillStyle = this.color;
    ctx.strokeRect(x + offset, y + offset, inner_width, inner_height);
    for (var i = 0; i < this.textLabel.length; i++)
    {
      this.textLabel[i].paint(ctx);
    }
  };
  
  this.handleMouseDown = function(event)
  {
      var event_x = event.offsetX / event.currentTarget.height;
      var event_y = event.offsetY / event.currentTarget.height;
      if(event_x >= this.x &&
        event_x <= this.x + this.width &&
        event_y >= this.y &&
        event_y <= this.y + this.height)
      {
        return true;
      }
  };
}

var Grid = function()
{
  this.visible = false;
  this.size = GRID_SIZE;
  this.inner_size = 6 * this.size/7;
  this.offset = (this.size - this.inner_size) / 2;
  this.squares = [];
  this.font_width = null;
  this.font_height = null;
  this.font_center_x = null;
  this.font_center_y = null;

  this.checkPulse = function()
  {
    return true;
  };

  this.handleMouseDown = function(event)
  {
    if (this.font_width &&
      this.font_height &&
      this.font_center_x &&
      this.font_center_y)
    {
      if(event.offsetX > this.font_center_x - this.font_width / 2 &&
        event.offsetX < this.font_center_x + this.font_width / 2 &&
        event.offsetY > this.font_center_y - this.font_height / 2 &&
        event.offsetY < this.font_center_y + this.font_height / 2)
      {
        this.visible = !this.visible;
        return true;
      }
    }
    return false;
  };

  this.paint = function(ctx)
  {
    ctx.fillStyle = MOVEABLE_COLOR;
    ctx.textBaseline="middle";
    ctx.textAlign="center";
    size = Math.round(this.size * g_canvas.height)
    this.font_height = Math.round(INVERSE_PHI * this.inner_size * g_canvas.height);
    ctx.font = this.font_height + "px Verdana";
    var text = "GRID: " + (this.visible ? "ON" : "OFF");
    this.font_width = ctx.measureText(text).width;
    this.font_center_x = Math.round(g_canvas.width / 2);
    this.font_center_y = g_canvas.height - size * 2;
    ctx.fillText(text, this.font_center_x, this.font_center_y)

    if (!this.visible)
    {
      return;
    }
    for(var i = this.squares.length - 1; i>=0; i--)
    {
      ctx.fillStyle = STATIC_COLOR;
      var offset = g_canvas.height * this.offset;
      ctx.fillRect(this.squares[i][0] * size + offset,
      this.squares[i][1] * size + offset, size - g_canvas.height*GRID_SIZE/7, size - g_canvas.height*GRID_SIZE/7);

    }
  };
}

var LetterBoxCollection = function()
{
  this.letterBoxList = [];
  this.alive = true;
  this.color = MOVEABLE_COLOR;

  this.handleTimeStep = function()
  {
  };

  this.checkPulse = function()
  {
    return this.alive;
  }

  this.handleMouseDown = function(event)
  {
    for(var i = this.letterBoxList.length - 1; i>=0; i--)
    {
      if(this.letterBoxList[i].handleMouseDown(event))
      {
        return true;
      }
    }
    return false;
  };

  this.paint = function(ctx)
  {
    for(var i = this.letterBoxList.length - 1; i>=0; i--)
    {
      this.letterBoxList[i].color = this.color
      this.letterBoxList[i].paint(ctx);
    }
  };

  this.transpose = function(deltaX, deltaY)
  {
    for(var i = this.letterBoxList.length - 1; i>=0; i--)
    {
      this.letterBoxList[i].transpose(deltaX, deltaY);
    }
  }

  this.snap = function(size)
  {
    for(var i = this.letterBoxList.length - 1; i>=0; i--)
    {
      this.letterBoxList[i].x = size * Math.round((this.letterBoxList[i].x)/size);
      this.letterBoxList[i].y = size * Math.round((this.letterBoxList[i].y)/size);
    }
  }
  
  this.offset = function()
  {
    var i = 0;
    var min_x = this.letterBoxList[i].x;
    var min_y = this.letterBoxList[i].y;
    for(i = 1; i < this.letterBoxList.length; i++)
    {
      min_x = Math.min(min_x,this.letterBoxList[i].x);
      min_y = Math.min(min_y,this.letterBoxList[i].y);
    }
    return [min_x, min_y];
  }
}

var LetterBox = function(x,y,size,letter)
{
  this.x = x;
  this.y = y;
  this.size = size;
  this.inner_size = (6 * this.size/7);
  this.offset = ((this.size - this.inner_size) / 2);
  this.letter = letter;
  this.color = MOVEABLE_COLOR; //overwritten by LetterBoxCollection
  this.alive = true;
  this.opaque = false;

  this.handleTimeStep = function()
  {
  };

  this.checkPulse = function()
  {
    return this.alive;
  }

  this.handleMouseDown = function(event)
  {
    var event_x = event.offsetX / event.currentTarget.height;
    var event_y = event.offsetY / event.currentTarget.height;
    //alert("this.x = " + this.x + ", this.size = " + this.size + ", event.offsetX = " + event.offsetX);
    var hit = this.x + this.size >= event_x &&
      event_x >= this.x &&
      this.y + this.size >= event_y &&
      event_y >= this.y;
    return hit;
  };

  this.paint = function(ctx)
  {
    ctx.lineJoin ="round";
    var size = Math.round(this.size*g_canvas.height);
    var offset = Math.round(this.offset*g_canvas.height);
    var x = Math.round(this.x*g_canvas.height);
    var y = Math.round(this.y*g_canvas.height);
    var inner_size = Math.round(this.inner_size*g_canvas.height);
    ctx.lineWidth = Math.round(size / (10*PHI));
    if(this.opaque)
    {
      ctx.fillStyle = "#f0f0f0";
      ctx.fillRect(x + offset, y + offset, inner_size, inner_size);
    }
    ctx.strokeStyle = this.color;
    ctx.fillStyle = this.color;
    ctx.strokeRect(x + offset, y + offset, inner_size, inner_size);
    ctx.textBaseline="middle";
    ctx.textAlign="center";
    ctx.font = Math.round(INVERSE_PHI * inner_size) + "px Verdana";
    ctx.fillText(this.letter,Math.round(x+size/2),Math.round(y+size/2));
  };

  this.transpose = function(deltaX, deltaY)
  {
    this.x += deltaX/g_canvas.height;
    this.y += deltaY/g_canvas.height;
  }
};

var VictoryCelebration = function()
{
  g_leveldone.play();
  this.letters = [];
  this.velocity = [0,0,0,0,0,0,0,0,0,0];
  this.bounces = [0,0,0,0,0,0,0,0,0,0];
  this.acceleration = 1;
  this.breakpoint = [1/2 - GRID_SIZE*2, 1/2];
  this.menu_button = null;
  this.next_button = null;
  this.bg = 0.0;
  var x = 4/3/2;
  var y = -GRID_SIZE*4;
  y -= GRID_SIZE*2;
  x -= GRID_SIZE*2 * 2.5;
  y -= 40/600;
  this.letters.push(new LetterBox(x,y,GRID_SIZE*2,"S"));
  this.letters.push(new LetterBox(x,y+GRID_SIZE*2,GRID_SIZE*2,"C"));
  x += GRID_SIZE*2;
  y += 20/600;
  this.letters.push(new LetterBox(x,y,GRID_SIZE*2,"T"));
  this.letters.push(new LetterBox(x,y+GRID_SIZE*2,GRID_SIZE*2,"L"));
  x += GRID_SIZE*2;  
  y -= 60/600;
  this.letters.push(new LetterBox(x,y,GRID_SIZE*2,"A"));
  this.letters.push(new LetterBox(x,y+GRID_SIZE*2,GRID_SIZE*2,"E"));
  x += GRID_SIZE*2;
  y += 20/600;
  this.letters.push(new LetterBox(x,y,GRID_SIZE*2,"G"));
  this.letters.push(new LetterBox(x,y+GRID_SIZE*2,GRID_SIZE*2,"A"));
  x += GRID_SIZE*2;
  y += 20/600;
  this.letters.push(new LetterBox(x,y,GRID_SIZE*2,"E"));
  this.letters.push(new LetterBox(x,y+GRID_SIZE*2,GRID_SIZE*2,"R"));

  this.handleTimeStep = function()
  {
    if(this.bg < .75)
    {
      this.bg += 0.02;
      if(this.bg >= .75)
      {
        this.menu_button = new TextLabelWithBoundingBox(["<< MENU"], 4/3/2 - 2.5 * GRID_SIZE*2, 1/2 + GRID_SIZE*2, GRID_SIZE*2 * 2.5, "black", GRID_SIZE);
        if(g_level < g_puzzles.length - 1)
        {
          this.next_button = new TextLabelWithBoundingBox(["NEXT >>"], 4/3/2, 1/2 + GRID_SIZE*2, GRID_SIZE*2 * 2.5, "black", GRID_SIZE);
        }
      }
    }
    
    for(var i = 0; i < this.letters.length; ++i)
    {
      if (this.bounces[i] < 20)
      {
        this.velocity[i] += this.acceleration;
        this.letters[i].transpose(0,this.velocity[i]);
        if (this.letters[i].y > this.breakpoint[i % 2])
        {
          this.letters[i].y = this.breakpoint[i % 2];
          this.bounces[i]++;
          this.velocity[i] = -0.5 * this.velocity[i];  
        }
      }
    }
  };
  
  this.handleMouseDown = function(event)
  {
    if(this.menu_button && this.menu_button.handleMouseDown(event))
    {
      switchToScreen(MenuScreen);
      return;
    }
    if(this.next_button && this.next_button.handleMouseDown(event))
    {
      g_level++;
      if(g_level > g_puzzles.length)
      {
        g_level--;
        return;
      }
      switchToScreen(GameScreen);
      return;
    }
  }

  this.paint = function(ctx)
  {
    ctx.fillStyle = "rgba(240, 240, 240, " + this.bg + ")";
    ctx.fillRect(0, 0, g_canvas.width, g_canvas.height);
    for(var i = 0; i < this.letters.length; ++i)
    {
      this.letters[i].opaque = true;
      this.letters[i].paint(ctx);
    }
    if (this.menu_button)
    {
      this.menu_button.paint(ctx);
    }
    if (this.next_button)
    {
      this.next_button.paint(ctx);
    }
  };

  this.checkPulse = function(ctx)
  {
    return true;
  }
};

var VerticalLabelBaselineEnum = {
  TOP: 0,
  MIDDLE: 1,
  BOTTOM: 2,
  properties: {
    0: { textBaseline: "top" },
    1: { textBaseline: "middle" },
    2: { textBaseline: "bottom" },
  }
};


var HorizontalLabelAlignEnum = {
  LEFT: 0,
  CENTER: 1,
  RIGHT: 2,
  properties: {
    0: { textAlign: "left" },
    1: { textAlign: "center" },
    2: { textAlign: "right" },
  }
};

var TextLabel = function(text, x, y, color, alignment, baseline, size)
{
  this.size = size;
  this.alignment = alignment;
  this.baseline = baseline;
  this.x = x;
  this.y = y;
  this.text_size = 0;
  this.color = color;
  this.text = text;
  
  this.handleMouseDown = function (event) 
  {
    var event_x = event.offsetX / event.currentTarget.height;
    var event_y = event.offsetY / event.currentTarget.height;
    switch (this.alignment)
    {
      case HorizontalLabelAlignEnum.LEFT:
        if (event_x < this.x || event_x > this.x + this.text_size)
        {
          return false;
        }
        break;
      case HorizontalLabelAlignEnum.RIGHT:
        if (event_x < this.x - this.text_size || event_x > this.x)
        {
          return false;
        }
        break;
      case HorizontalLabelAlignEnum.CENTER:
        if (event_x < this.x - this.text_size / 2 || event_x > this.x + this.text_size / 2)
        {
          return false;
        }
        break;
      default:
        return false;
    }
    
    switch (this.baseline)
    {
      case VerticalLabelBaselineEnum.TOP:
        if (event_y < this.y || event_y > this.y + this.size)
        {
          return false;
        }
        break;
      case VerticalLabelBaselineEnum.BOTTOM:
        if (event_y < this.y - this.size || event_y > this.y)
        {
          return false;
        }
        break;
      case VerticalLabelBaselineEnum.MIDDLE:
        if (event_y < this.y - this.size / 2 || event_y > this.y + this.size / 2)
        {
          return false;
        }
        break;
      default:
        return false;
    }
    
    return true;
  },
  
  this.paint = function(ctx)
  {
    var size = this.size * g_canvas.height;
    var x = this.x * g_canvas.height;
    var y = this.y * g_canvas.height;
    ctx.font = Math.round(size) + "px Verdana";
    this.text_size = ctx.measureText(this.text).width / g_canvas.height;
    ctx.textAlign = HorizontalLabelAlignEnum.properties[this.alignment].textAlign;
    ctx.textBaseline = VerticalLabelBaselineEnum.properties[this.baseline].textBaseline;
    ctx.fillStyle = this.color;
    ctx.fillText(this.text, x, y);
  }
};

var Timer = function(timer, callback, parameter)
{
  this.current_time = timer;
  this.callback = callback;
  this.parameter = parameter;
  this.handleTimeStep = function()
  {
    this.current_time--;
    if(this.current_time <= 0)
    {
      callback(this.parameter);
    }

  };
  this.checkPulse = function(){
        return this.current_time > 0;
  };
};
    
var MouseButtonEnum = {
  NONE: 0,
  LEFT: 1,
  RIGHT: 2,
  BOTH: 3,
  properties: {
    random: function() { return Math.floor(Math.random() * 4); } 
  }
};
    
var TutorialScreen = {
  init: function () {
    this.reset();
  },
  reset: function () {
    this.mouse_instructions = []
    this.mouse_instructions.push([3,["Welcome to Crossword Puzzles!","","click to continue..."]]);
    this.mouse_instructions.push([3,["Reassemble the pieces into a crossword puzzle","in order to solve each level","","click to continue..."]]);
    this.mouse_instructions.push([3,["Each word in the completed puzzle is","related to that puzzle's title","","click to continue..."]]);
    this.mouse_instructions.push([4]);
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([4])
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([4])
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([4])
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([4])
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([4])
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([3,["This puzzle's title is","\"THE NAME OF THE GAME\"","","What could that mean?","","click to continue..."]]);
    this.mouse_instructions.push([3,["You can drag tiles together with left click","","click to continue..."]]);
    this.mouse_instructions.push([0, 6*GRID_SIZE + GRID_SIZE/2, 5*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([1,MouseButtonEnum.LEFT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([0, 15*GRID_SIZE + GRID_SIZE/2, 10*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0, 13*GRID_SIZE + GRID_SIZE/2, 8*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([3,["You can drag connected groups with right click","","click to continue..."]]);
    /*
    */
    this.mouse_instructions.push([0, 17*GRID_SIZE + GRID_SIZE/2, 10*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([1,MouseButtonEnum.RIGHT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([0, 13*GRID_SIZE + GRID_SIZE/2, 7*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0, 11*GRID_SIZE + GRID_SIZE/2, 9*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([3,["You can toggle the grid showing the shape of the","completed puzzle on and off","","click to continue..."]]);
    this.mouse_instructions.push([0,4/3 / 2,1 - GRID_SIZE*2]);
    this.mouse_instructions.push([1,MouseButtonEnum.LEFT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0,4/3 / 2,1 - GRID_SIZE*4]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([0,4/3 / 2,1 - GRID_SIZE*2]);
    this.mouse_instructions.push([1,MouseButtonEnum.LEFT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0,4/3 / 2, 1 - GRID_SIZE*4]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([3,["Reassemble all the words to complete the puzzle!","","click to continue..."]]);
    this.mouse_instructions.push([0, 5*GRID_SIZE + GRID_SIZE/2, 11*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.LEFT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([0, 13*GRID_SIZE + GRID_SIZE/2, 9*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0, 18*GRID_SIZE + GRID_SIZE/2, 6*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.LEFT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([0, 9*GRID_SIZE + GRID_SIZE/2, 9*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0, 6*GRID_SIZE + GRID_SIZE/2, 6*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,50]);
    this.mouse_x = 4/3/ 2;
    this.mouse_y = 1/ 2;
    this.mouse_buttons = MouseButtonEnum.NONE;

    this.mouseSpeed = 10/600;
    this.idle_timer = 0;
    this.gameScreen = GameScreen;
    this.gameScreen.reset();
    this.gameScreen.name = "THE NAME OF THE GAME";
    this.text = null;
    /*var temp_level = g_level;
    g_level = g_puzzles.length;
    this.gameScreen.reset();
    
    this.gameScreen.loadLevel({"pieces":[{"str":["PUZZ"],"x":16,"y":6,"vx":7,"vy":9},{"str":["WO"],"x":6,"y":5,"vx":11,"vy":7},{"str":["LES","..S"],"x":3,"y":11,"vx":11,"vy":9},{"str":["C.","RD","O."],"x":17,"y":9,"vx":13,"vy":6}],"grid":{"str":["......O.","....OOOO","......O.","OOOOOOO.","......O."],"x":7,"y":6},"name":"THE NAME OF THE GAME"});
    g_level = temp_level;
    */
  },
  handleMouseDown: function (event) {
    if (!this.gameScreen.solved && this.gameScreen.backTextSize &&
      this.gameScreen.textHeight)
    {
      if(event.offsetY > g_canvas.height - this.gameScreen.textHeight)
      {
        if(event.offsetX < this.gameScreen.backTextSize)
        {
          switchToScreen(MenuScreen);
          return true;
        }
      }
    }
    if (this.mouse_instructions.length === 0)
    {
      this.gameScreen.handleMouseDown(event);
      return;
    }
    var current_instruction = this.mouse_instructions[0];
    if (current_instruction[0] === 3)
    {
      this.mouse_instructions.splice(0,1);
      this.idle_timer = 0;
      this.text = null;
    }
  },
  handleMouseUp: function (event) {},
  handleMouseMove: function (event) {},
  handleKeyDown: function (event) {},
  handleKeyUp: function (event) {},
  handleTimeStep: function () {
    if (this.mouse_instructions.length === 0)
    {
      this.gameScreen.handleTimeStep();
      return;
    }
    
    var current_instruction = this.mouse_instructions[0];
    var current_instruction_done = true;
    if (current_instruction[0] == 0)
    {
      var dy = this.mouse_y - current_instruction[2];
      var dx = this.mouse_x - current_instruction[1];
      if (Math.abs(dy) < this.mouseSpeed)
      {
        this.mouse_y = current_instruction[2];
      }
      else if(dy < 0)
      {
        this.mouse_y += this.mouseSpeed;
        current_instruction_done = false;
      }
      else if(dy > 0)
      {
        this.mouse_y -= this.mouseSpeed;
        current_instruction_done = false;
      }
      
      if (Math.abs(dx) < this.mouseSpeed)
      {
        this.mouse_x = current_instruction[1];
      }
      else if(dx < 0)
      {
        this.mouse_x += this.mouseSpeed;
        current_instruction_done = false;
      }
      else if(dx > 0)
      {
        this.mouse_x -= this.mouseSpeed;
        current_instruction_done = false;
      }
      this.gameScreen.handleMouseMove(
        {offsetX: this.mouse_x * g_canvas.height, offsetY: this.mouse_y * g_canvas.height,
        currentTarget : {height : canvas.height}});
    }
    
    if (current_instruction[0] == 1)
    {
      var old_buttons = this.mouse_buttons;
      this.mouse_buttons = current_instruction[1];
      if ((old_buttons === MouseButtonEnum.NONE || old_buttons === MouseButtonEnum.RIGHT) &&
        (this.mouse_buttons === MouseButtonEnum.LEFT || this.mouse_buttons === MouseButtonEnum.BOTH))
      {
        this.gameScreen.handleMouseDown({button: 0, offsetX: this.mouse_x * g_canvas.height, offsetY: this.mouse_y * g_canvas.height,
        currentTarget : {height : canvas.height}});
      }
      if ((old_buttons === MouseButtonEnum.NONE || old_buttons === MouseButtonEnum.LEFT) &&
        (this.mouse_buttons === MouseButtonEnum.RIGHT || this.mouse_buttons === MouseButtonEnum.BOTH))
      {
        this.gameScreen.handleMouseDown({button: 2, offsetX: this.mouse_x * g_canvas.height, offsetY: this.mouse_y * g_canvas.height,
        currentTarget : {height : canvas.height}});
      }
      if ((old_buttons === MouseButtonEnum.BOTH || old_buttons === MouseButtonEnum.RIGHT) &&
        (this.mouse_buttons === MouseButtonEnum.LEFT || this.mouse_buttons === MouseButtonEnum.NONE))
      {
        this.gameScreen.handleMouseUp({button: 2, offsetX: this.mouse_x * g_canvas.height, offsetY: this.mouse_y * g_canvas.height,
        currentTarget : {height : canvas.height}});
      }
      if ((old_buttons === MouseButtonEnum.BOTH || old_buttons === MouseButtonEnum.LEFT) &&
        (this.mouse_buttons === MouseButtonEnum.RIGHT || this.mouse_buttons === MouseButtonEnum.NONE))
      {
        this.gameScreen.handleMouseUp({button: 0, offsetX: this.mouse_x * g_canvas.height, offsetY: this.mouse_y * g_canvas.height,
        currentTarget : {height : canvas.height}});
      }
    }
    
    if (current_instruction[0] == 2)
    {
      this.idle_timer++;
      if (this.idle_timer < current_instruction[1])
      {
        current_instruction_done = false;
      }
    }
    
    if (current_instruction[0] === 3)
    {
      if (this.text === null)
      {
        this.text = new TextLabelWithBoundingBox(current_instruction[1], 4/3/2 - GRID_SIZE*10, 1/2 - current_instruction[1].length/2 * GRID_SIZE, GRID_SIZE*20, "black", GRID_SIZE);
      }
      current_instruction_done = false;
    }
    
    if (current_instruction[0] === 4)
    {
      if (this.gameScreen.name_color === "black")
      {
        this.gameScreen.name_color = "gray";
      }
      else
      {
        this.gameScreen.name_color = "black";
      }
    }
    
    if (current_instruction_done) 
    {
      this.mouse_instructions.splice(0,1);
      this.idle_timer = 0;
      this.text = null;
    }
  },
  
  paint: function () {
    this.gameScreen.paint();
    if (this.mouse_instructions.length > 0)
    {
      this.drawMouse(g_ctx, this.mouse_x, this.mouse_y, this.mouse_buttons);
    }
    if (this.text)
    {
      g_ctx.fillStyle = "rgba(240, 240, 240, .75)";
      g_ctx.fillRect(
        0, 0,
        g_canvas.width,
        g_canvas.height);
      this.text.paint(g_ctx);
    }
  },

  drawMouse: function (ctx,centerX, centerY, mouseButton) {
    var offset = 2/35 * GRID_SIZE * g_canvas.height;
    var radius = 12/35 * GRID_SIZE * g_canvas.height;
    centerX = centerX * g_canvas.height;
    centerY = centerY * g_canvas.height;
    var border = offset/2;
    var left_color = "grey";
    var right_color = "grey";
    if(mouseButton === MouseButtonEnum.LEFT || mouseButton === MouseButtonEnum.BOTH)
    {
      left_color = "black";
    }
    if(mouseButton === MouseButtonEnum.RIGHT || mouseButton === MouseButtonEnum.BOTH)
    {
      right_color = "black";
    }
    this.drawWedge(ctx, right_color, centerX + border, centerY - border, radius, 3 * Math.PI / 2, 0);
    this.drawWedge(ctx, left_color, centerX - border, centerY - border, radius, Math.PI, 3 * Math.PI / 2);
    var width = (offset + 2 * radius);
    var height = 8/35 * GRID_SIZE * g_canvas.height;
    ctx.fillStyle = "gray";
    ctx.fillRect(centerX - width/2, centerY + border, width, height);
    this.drawWedge(ctx, "gray", centerX, centerY + border + height, radius + border, 0, Math.PI);
  },

  drawWedge: function(ctx, color, centerX, centerY, radius, startAngle, endAngle)
  {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(centerX,centerY);
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
    ctx.closePath();
    ctx.fill();
  }
};

//##########################################################################
var MenuScreen = {
  init: function () {
    this.current_page = 0;
    this.reset();
  },
  reset: function () {
    this.static_labels = [];
    this.levels_per_page = 7;
    this.pages = Math.floor(g_puzzles.length / this.levels_per_page);
    if (g_puzzles.length % this.levels_per_page !== 0)
    {
      this.pages++;
    }
    this.loadLevelLabels();
    var width = 4/3;
    var height = 1;
    var y = height/2;
    this.static_labels.push(new TextLabel("LEVEL SELECT", width/2, (y + 26/35 * GRID_SIZE * -5),
        "black", HorizontalLabelAlignEnum.CENTER, VerticalLabelBaselineEnum.MIDDLE, (INVERSE_PHI * 26/35 * GRID_SIZE)));
    this.page_left = new TextLabel("<<", 0, height, "gray", HorizontalLabelAlignEnum.LEFT, VerticalLabelBaselineEnum.BOTTOM, (INVERSE_PHI * 26/35 * GRID_SIZE));
    this.page_right = new TextLabel(">>", width, height, "gray", HorizontalLabelAlignEnum.RIGHT, VerticalLabelBaselineEnum.BOTTOM, (INVERSE_PHI * 26/35 * GRID_SIZE));
  },
  loadLevelLabels: function () {
    this.level_labels = [];
    var y = 1/2;
    var width = 4/3;
    var offset = this.current_page * this.levels_per_page;
    for (var i = 0; i + offset < g_puzzles.length && i < this.levels_per_page; i++)
    {
      var level_name = g_puzzles[i + offset].name;
      if (g_completed[i + offset])
      {
        level_name += " \u2713"
      }
      this.level_labels.push(new TextLabel(level_name, width/2, ((i - 3) * 26/35 * GRID_SIZE + y),
        "gray", HorizontalLabelAlignEnum.CENTER, VerticalLabelBaselineEnum.MIDDLE, (INVERSE_PHI * 26/35 * GRID_SIZE)));
    }
    this.page_display = new TextLabel("PAGE " + (this.current_page+1) + "/" + this.pages, width/2, (y + 26/35 * GRID_SIZE * 5),
      "black", HorizontalLabelAlignEnum.CENTER, VerticalLabelBaselineEnum.MIDDLE, (INVERSE_PHI * 26/35 * GRID_SIZE));
  },
  handleMouseDown: function (event) {
    for (var i = 0; i < this.level_labels.length; i++)
    {
      if(this.level_labels[i].handleMouseDown(event))
      {
        g_level = i + this.current_page * this.levels_per_page;
        if (g_level === 0)
        {
          switchToScreen(TutorialScreen);
          return;
        }
        switchToScreen(GameScreen);
        return;
      }
    }
    if(this.page_left.handleMouseDown(event))
    {
      if(this.current_page > 0)
      {
        this.current_page--;
        this.loadLevelLabels();
      }
    }
    if(this.page_right.handleMouseDown(event))
    {
      if(this.current_page < this.pages - 1)
      {
        this.current_page++;
        this.loadLevelLabels();
      }
    }
    
  },
  handleMouseUp: function (event) {},
  handleMouseMove: function (event) {
    for (var i = 0; i < this.level_labels.length; i++)
    {
      if(this.level_labels[i].handleMouseDown(event))
      {
        this.level_labels[i].color = "black";
      }
      else
      {
        this.level_labels[i].color = "gray";
      }
    }
    if(this.page_left.handleMouseDown(event))
    {
      this.page_left.color = "black";
    }
    else
    {
      this.page_left.color = "gray";
    }
    if(this.page_right.handleMouseDown(event))
    {
      this.page_right.color = "black";
    }
    else
    {
      this.page_right.color = "gray";
    }
  },
  handleKeyDown: function (event) {},
  handleKeyUp: function (event) {},
  handleTimeStep: function () {    
  },
  
  paint: function () {
    g_ctx.setTransform(1, 0, 0, 1, 0, 0);

    g_ctx.fillStyle = "#f0f0f0";
    g_ctx.fillRect(
        0, 0,
        g_canvas.width,
        g_canvas.height);
    for (var i = 0; i < this.level_labels.length; i++)
    {
      this.level_labels[i].paint(g_ctx);
    }
    for (var i = 0; i < this.static_labels.length; i++)
    {
      this.static_labels[i].paint(g_ctx);
    }
    this.page_display.paint(g_ctx);
    if (this.current_page > 0)
    {
      this.page_left.paint(g_ctx);
    }
    if(this.current_page < this.pages - 1)
    {
      this.page_right.paint(g_ctx);
    }
  }
};

//##########################################################################
var GameScreen = {

    init: function () {
      this.reset();
    },

    makePiece: function (letters, x = 0, y = 0) {
      var letter_box_collection = new LetterBoxCollection();
      var defaultX = 0;
      var defaultY = 0;
      if ( x === 0 && y === 0)
      {
        defaultX = Math.round(Math.random()*(g_canvas.width - GRID_SIZE*4)) + GRID_SIZE*2;
        defaultY = Math.round(Math.random()*(g_canvas.height - GRID_SIZE*4)) + GRID_SIZE*2;
      }
      for (var i = 0; i < letters.length; i++)
      {
        for (var j = 0; j < letters[i].length; j++)
        {
          if (letters[i].charAt(j) !== " " && letters[i].charAt(j) !== ".")
          {
            var coord_x = (defaultX + GRID_SIZE * (j + x));
            var coord_y = (defaultY + GRID_SIZE * (i + y));
            letter_box_collection.letterBoxList.push(
              new LetterBox(coord_x, coord_y, GRID_SIZE, letters[i].charAt(j)));
          }
        }
      }
      letter_box_collection.snap(GRID_SIZE);
      this.paint_list.push(letter_box_collection);
      this.draggable_list.push(letter_box_collection);
      this.name_color = "black";
    },

    makeGrid: function (lines, offsetX, offsetY) {
      var grid = new Grid();
      for (var i = 0; i < lines.length; i++)
      {
        for (var j = 0; j < lines[i].length; j++)
        {
          if (lines[i].charAt(j) !== " " && lines[i].charAt(j) !== ".")
          {
            grid.squares.push([j + offsetX, i + offsetY]);
          }
        }
      }
      this.paint_list.push(grid);
      this.clickable_list.push(grid);
    },

    loadLevel: function (stage)
    {
      for(var i = 0; i < stage.pieces.length; i++)
      {
        this.makePiece(stage.pieces[i].str,
          stage.pieces[i].x,
          stage.pieces[i].y
        );
      }
      this.makeGrid(stage.grid.str,
        stage.grid.x,
        stage.grid.y
      );
      this.name = stage.name;
    },
    
    populateLevel: function (stage)
    {
      if (stage < g_puzzles.length)
      {
        
        this.loadLevel(g_puzzles[stage]);
        
        //alert(JSON.stringify(g_puzzles));
        //alert(decodeURIComponent(encodeURIComponent(JSON.stringify(g_puzzles[stage]))));
        return;
      }
      else
      {
        this.name = "INVALID PUZZLE";
      }
    },
    
    checkAdjancent: function(tileSet1, tileSet2)
    {
      for(var j = 0; j < tileSet1.letterBoxList.length; j++)
      {
        for(var k = 0; k < tileSet2.letterBoxList.length; k++)
        {
          var distance = Math.abs(tileSet1.letterBoxList[j].x - tileSet2.letterBoxList[k].x) + 
            Math.abs(tileSet1.letterBoxList[j].y - tileSet2.letterBoxList[k].y);
          if (GRID_SIZE*.95 < distance && distance < GRID_SIZE*1.05)
          {
            return true;
          }
        }
      }
      return false;
    },
    
    checkOnScreen: function(tileSet)
    {
      for(var j = 0; j < tileSet.letterBoxList.length; j++)
      {
        if (tileSet.letterBoxList[j].x < 4/3 && 
          tileSet.letterBoxList[j].y < 1 &&
          tileSet.letterBoxList[j].x > 0 &&
          tileSet.letterBoxList[j].y > 0)
        {
          return true;
        }
      }
      return false;
    },
    
    returnToScreen: function(tileSet)
    {
      for(var j = 0; j < tileSet.letterBoxList.length; j++)
      {
        while(tileSet.letterBoxList[j].x < 0)
        {
          tileSet.transpose(GRID_SIZE * g_canvas.height,0);
        }
        while(tileSet.letterBoxList[j].y < 0)
        {
          tileSet.transpose(0, GRID_SIZE * g_canvas.height);
        }
        while(tileSet.letterBoxList[j].x > 4/3)
        {
          tileSet.transpose(-GRID_SIZE * g_canvas.height, 0);
        }
        while(tileSet.letterBoxList[j].y > 1)
        {
          tileSet.transpose(0, -GRID_SIZE * g_canvas.height);
        }
      }
    },
    
    findOffscreenAdjacentTileSets : function()
    {
      var adjacencySet = Array(this.draggable_list.length).fill(false);
      
      var unexpanded;
      var returnSet;
      var needs_recentering;
      for(var j = 0; j < adjacencySet.length; j++)
      {
        if(adjacencySet[j])
        {
          continue;
        }
        
        returnSet = [];
        needs_recentering = true;
        adjacencySet[j] = true;
        unexpanded = [this.draggable_list[j]];
        while(unexpanded.length > 0)
        {
          var tileSet = unexpanded.pop();
          returnSet.push(tileSet);
          needs_recentering = needs_recentering && !this.checkOnScreen(tileSet)
          for(var i = this.draggable_list.length - 1; i>=0; i--)
          {
            if (!adjacencySet[i])
            {
              if (this.checkAdjancent(tileSet,this.draggable_list[i]))
              {
                adjacencySet[i] = true;
                unexpanded.push(this.draggable_list[i]);
              }
            }
          }
        }
        if(needs_recentering)
        {
          //alert(returnSet.length + " tiles lost");
          for(var i = 0; i < returnSet.length; ++i)
          {
            this.returnToScreen(returnSet[i]);
          }
        }
      }
      return;
    },

    findAdjacentTileSets: function(draggable_list_item_index)
    {
      var adjacencySet = Array(this.draggable_list.length).fill(false);
      adjacencySet[draggable_list_item_index] = true;
      var returnSet = [];
      var unexpanded = [ this.draggable_list[draggable_list_item_index] ];
      while(unexpanded.length > 0)
      {
        var tileSet = unexpanded.pop();
        returnSet.push(tileSet);
        for(var i = this.draggable_list.length - 1; i>=0; i--)
        {
          if (!adjacencySet[i])
          {
            if (this.checkAdjancent(tileSet,this.draggable_list[i]))
            {
              adjacencySet[i] = true;
              unexpanded.push(this.draggable_list[i]);
            }
          }
        }
      }
      return returnSet;
    },
    
    reset: function () {
      this.paint_list = [];
      this.timestep_list = [];
      this.draggable_list = [];
      this.clickable_list = [];
      this.dragged_item_collection = null;
      this.mouse_pos = [null, null];
      this.name = "";
      this.backTextSize = null;
      this.textHeight = null;
      this.solved = false;

      this.populateLevel(g_level);

      /*
      for (var i = 0; i < g_canvas.width; i += GRID_SIZE)
      {
        var box = new LetterBox(i, 0, GRID_SIZE, "0123456789".charAt((i / GRID_SIZE) % 10));
        box.color = STATIC_COLOR;
        this.paint_list.push(box);
      }
      for (var i = GRID_SIZE; i < g_canvas.height; i += GRID_SIZE)
      {
        var box = new LetterBox(0, i, GRID_SIZE, "0123456789".charAt((i / GRID_SIZE) % 10));
        box.color = STATIC_COLOR;
        this.paint_list.push(box);
      }
      //*/
    },
    
    checkForSolved: function () {
      if (this.solved)
      {
        return;
      }
      var dx;
      var dy;
      var dim;
      for (var i = 0; i < this.draggable_list.length; ++i)
      {
        dim = this.draggable_list[i].offset();
        if (i === 0)
        {
          dx = g_puzzles[g_level].pieces[i].vx - Math.round(dim[0]/GRID_SIZE);
          dy = g_puzzles[g_level].pieces[i].vy - Math.round(dim[1]/GRID_SIZE);
        }
        else
        {
          if(dx !== g_puzzles[g_level].pieces[i].vx - Math.round(dim[0]/GRID_SIZE) ||
          dy !== g_puzzles[g_level].pieces[i].vy - Math.round(dim[1]/GRID_SIZE))
          {
            return;
          }
        }
      }
      this.solved = true;
      this.draggable_list = [];
      this.clickable_list = [];
      var victory = new VictoryCelebration();
      this.paint_list.unshift(victory);
      this.timestep_list.unshift(victory);
      this.clickable_list.push(victory);
      
      g_completed[g_level] = true;
    },
    
    handleMouseDown: function (event) {
      for(var i = this.draggable_list.length - 1; i>=0; i--)
      {
        if(!this.draggable_list[i].checkPulse())
        {
          this.draggable_list.splice(i,1);
        }
        else
        {
          if(this.draggable_list[i].handleMouseDown(event))
          {
            if(event.button == 0)
            {
              this.draggable_list[i].color = MOVE_COLOR;
              this.dragged_item_collection = [ this.draggable_list[i] ];
              g_click.stop();
              g_click.play();
            }
            else if(event.button == 2)
            {
              this.draggable_list[i].color = MOVE_COLOR;
              this.dragged_item_collection = this.findAdjacentTileSets(i);
              g_click.stop();
              g_click.play();
            }
            return true;
          }
        }
      }
      for(var i = this.clickable_list.length - 1; i>=0; i--)
      {
        if(!this.clickable_list[i].checkPulse())
        {
          this.clickable_list.splice(i,1);
        }
        else
        {
          if(this.clickable_list[i].handleMouseDown(event))
          {
            return true;
          }
        }
      }

      if (!this.solved && this.backTextSize &&
        this.textHeight)
      {
        if(event.offsetY > g_canvas.height - this.textHeight)
        {
          if(event.offsetX < this.backTextSize)
          {
            switchToScreen(MenuScreen);
            return true;
          }
        }
      }
      return false;
    },
    
    handleMouseMove: function (event) {
      var old_x = this.mouse_pos[0];
      var old_y = this.mouse_pos[1];
      var i = 0;
      this.mouse_pos[0] = event.offsetX;
      this.mouse_pos[1] = event.offsetY;
      if (this.dragged_item_collection)
      {
        for(i = 0; i < this.dragged_item_collection.length; i++)
        {
          this.dragged_item_collection[i].transpose(this.mouse_pos[0] - old_x, this.mouse_pos[1] - old_y);
        }
      }
    },
    handleMouseUp: function (event) {
      if (this.dragged_item_collection)
      {
        for(i = 0; i < this.dragged_item_collection.length; i++)
        {
          this.dragged_item_collection[i].color = MOVEABLE_COLOR;
          this.dragged_item_collection[i].snap(GRID_SIZE);
          g_click.stop();
          g_click.play();
        }
        this.checkForSolved();
        this.findOffscreenAdjacentTileSets();
      }
      this.dragged_item_collection = null;
    },
    handleKeyDown: function (event) {
    },
    handleKeyUp: function (event) {
    },
    handleTimeStep: function () {
      for(var i = this.timestep_list.length - 1; i>=0; i--)
      {
        if(!this.timestep_list[i].checkPulse())
        {
          this.timestep_list.splice(i,1);
        }
        else
        {
          this.timestep_list[i].handleTimeStep();
        }
      }
    },
    paint: function () {
      g_ctx.setTransform(1, 0, 0, 1, 0, 0);

      g_ctx.fillStyle = "#f0f0f0";
      g_ctx.fillRect(
          0, 0,
          g_canvas.width,
          g_canvas.height);
      g_ctx.fillStyle = this.name_color;
      g_ctx.textBaseline="middle";
      g_ctx.textAlign="center";
      this.textHeight = Math.round(INVERSE_PHI * (GRID_SIZE - GRID_SIZE/7) * g_canvas.height);
      g_ctx.font = this.textHeight + "px Verdana";
      g_ctx.fillText(this.name,Math.round(g_canvas.width/2),Math.round(GRID_SIZE*2*g_canvas.height));
      g_ctx.textBaseline = "bottom";
      g_ctx.textAlign = "left"
      g_ctx.fillStyle = "black";
      this.backTextSize = g_ctx.measureText("<< MENU").width;
      g_ctx.fillText("<< MENU", 0, g_canvas.height);

      for (var i = this.paint_list.length - 1; i>=0; i--)
      {
        if(!this.paint_list[i].checkPulse())
        {
          this.paint_list.splice(i,1);
        }
        else
        {
          this.paint_list[i].paint(g_ctx);
        }
      }
    },
};

//##########################################################################

//--------------------------------------------------------------------------
var ResourceTracker = {
    m_added: 1, // I track myself loading
    m_loaded: 0,
    m_layout: null,
    m_ready : false,

    reset: function ()
    {},
    
    //----------------------------------------------------------------------
    // from Screen
    init: function ()
    {
        this.onload(null); //and here I'm loaded
    },

    //----------------------------------------------------------------------
    // from Screen
    reset: function ()
    {},

    //----------------------------------------------------------------------
    // from Screen
    handleMouseMove: function ()
    {},
    
    //----------------------------------------------------------------------
    // from Screen
    handleMouseDown: function ()
    {
      if (m_ready)
      {
        m_ready = false;
        g_mainloop.loop();
        g_mainloop.play().setVolume(0).fadeTo(50,10000);
        switchToScreen(MenuScreen);
      }
    },

    //----------------------------------------------------------------------
    // from Screen
    handleMouseUp: function ()
    {},

    //----------------------------------------------------------------------
    // from Screen
    handleKeyDown: function ()
    {},

    //----------------------------------------------------------------------
    // from Screen
    handleKeyUp: function (event)
    {},

    //----------------------------------------------------------------------
    // from Screen
    handleTimeStep: function ()
    {
      if (this.m_loaded == this.m_added)
      {
        this.onAllLoaded();
      }
    },

    //----------------------------------------------------------------------
    // from Screen
    paint: function ()
    {
        g_ctx.setTransform(1, 0, 0, 1, 0, 0);

        // paint the background
        g_ctx.fillStyle = "#f0f0f0";
        g_ctx.fillRect(
            0, 0,
            g_canvas.width,
            g_canvas.height);

        g_ctx.font="Bold 80px Arial";
        g_ctx.fillStyle = "rgb(0, 0, 0)";
        g_ctx.textAlign = "center";
        g_ctx.textBaseline = "middle";
        g_ctx.fillText(
            Math.floor(100 * this.m_loaded / this.m_added) + "%",
            g_canvas.width / 2,
            g_canvas.height / 2
        );
        if (100 === Math.floor(100 * this.m_loaded / this.m_added))
        {
          g_ctx.font="20px Arial";
          g_ctx.fillText(
              "click to continue",
              g_canvas.width / 2,
              g_canvas.height / 2 + 40
          );
        }
    },


    //----------------------------------------------------------------------
    add: function ()
    {
        ++this.m_added;
    },

    //----------------------------------------------------------------------
    // from Image.onload
    onload: function (event)
    {
        ++this.m_loaded;
        if (this.m_loaded == this.m_added)
        {
            this.onAllLoaded();
        }
    },

    //----------------------------------------------------------------------
    onAllLoaded: function ()
    {
      m_ready = true;
    }
};

//--------------------------------------------------------------------------
var AudioComponents = {
};

//--------------------------------------------------------------------------
var GraphicComponents = {
};

//##########################################################################
// game engine

//--------------------------------------------------------------------------
function init()
{
    //Canvas stuff
    g_canvas = document.getElementById("canvas");
    //g_canvas.style.cursor = 'none';
    g_ctx = g_canvas.getContext("2d");
    g_ctx.textAlign="start";
    g_ctx.textBaseline="middle";
    g_level = 0;
    g_completed = [];
    for (var i = 0; i < g_puzzles.length; i++)
    {
      g_completed.push(false);
    }

    g_canvas.addEventListener("mousedown", function (event) {
        g_current_screen.handleMouseDown(event);
    }, false);

    g_canvas.addEventListener("mouseup", function (event) {
        g_current_screen.handleMouseUp(event);
    }, false);

    g_canvas.addEventListener("mouseleave", function (event) {
        g_current_screen.handleMouseUp(event);
    }, false);

    g_canvas.addEventListener("mouseout", function (event) {
        g_current_screen.handleMouseUp(event);
    }, false);

    g_canvas.addEventListener("mousemove", function (event) {
        g_current_screen.handleMouseMove(event);
    }, false);

    document.addEventListener("keydown", function (event) {
        g_current_screen.handleKeyDown(event);
    }, false);

    document.addEventListener("keyup", function (event) {
        g_current_screen.handleKeyUp(event);
    }, false);

    g_mainloop = Util.loadAudio("assets/mainloop.wav", ResourceTracker);
    g_click = Util.loadAudio("assets/click.wav", ResourceTracker);
    g_leveldone = Util.loadAudio("assets/leveldone.wav", ResourceTracker);
    // can't do this until you've set up canvas_width and canvas_height
    //ResourceTracker init must be called after all requests to
    //loadImage/loadAudio
    ResourceTracker.init();
    GameScreen.init();
    TutorialScreen.init();
    MenuScreen.init();

    switchToScreen(ResourceTracker);
    
    var resize = function ()
    {
      var widthToHeightRatio = 4/3;
      var currentWidthToHeightRatio = window.innerWidth/window.innerHeight;
      if(currentWidthToHeightRatio < widthToHeightRatio)
      {
        g_canvas.width = window.innerWidth;
        g_canvas.height = window.innerWidth / widthToHeightRatio;
        g_canvas.style.left = "0px";
        g_canvas.style.top = Math.floor((window.innerHeight - g_canvas.height)/2) + "px";
      }
      else
      {
        g_canvas.width = window.innerHeight * widthToHeightRatio;
        g_canvas.height = window.innerHeight;
        g_canvas.style.left = Math.floor((window.innerWidth - g_canvas.width)/2) + "px";
        g_canvas.style.top = "0px"; 
      }
      
      if (g_current_screen)
      {
        g_ctx.save();
        g_current_screen.paint(g_ctx);
        g_ctx.restore();
      }
      
    };
    window.addEventListener('resize', resize, false);
    window.addEventListener('orientationchange', resize, false);
    resize();

    // start processing events
    setTimeout(eventLoop, 40);
}

//--------------------------------------------------------------------------
function switchToScreen(screen)
{
    screen.reset();
    g_current_screen = screen;
}

//--------------------------------------------------------------------------
function eventLoop()
{
    var start_time = Date.now();

    g_current_screen.handleTimeStep();
    g_current_screen.paint(g_ctx);

    var end_time = Date.now();
    var comp_time = end_time - start_time;
    if (comp_time > 40 || comp_time < 0) {
        setTimeout(eventLoop, 0);
    }
    else
    {
        setTimeout(eventLoop, 40 - comp_time);
    }
}

// launch the game once the document is fully loaded
window.addEventListener("load", init);

</script>
</body>
</html>

