<!DOCTYPE html>
<html>
<head>
    <title>Crossword Puzzles</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<canvas oncontextmenu="return false;" style = 'position: absolute; left: 0px; top: 0px;' id="canvas" width="800" height="600"></canvas>
<script src="../gameEngine/buzz.min.js" type="text/javascript"></script>
<script src="../gameEngine/engine.js" type="text/javascript"></script>
<script src="puzzles.js" type="text/javascript"></script>
<script src="entities.js" type="text/javascript"></script>
<script>
//##########################################################################
// The game

var g_level;
var g_completed;
var g_leveldone;
var g_click;
var g_mainloop;
var g_muted = false;
var g_settings;
var g_muted_icon;
var g_unmuted_icon;
var g_aspect_ratio = 805/595;
var levelcounts = 0;

var PHI = 1.61803398875;
var INVERSE_PHI = 0.61803398875;


var GRID_SIZE = 1/17;
var MOVE_COLOR = "red";
var MOVEABLE_COLOR = "black";
var STATIC_COLOR = "lightgrey";

//--------------------------------------------------------------------------
const Util = {

    //----------------------------------------------------------------------
    forEach: function (obj, fn)
    {
        var key;
        for (key in obj)
        {
            if (obj.hasOwnProperty(key))
            {
                fn(obj[key]);
            }
        }
    },

    //----------------------------------------------------------------------
    randomItem: function (arr)
    {
        return arr[Math.floor(Math.random() * arr.length)];
    },

    //----------------------------------------------------------------------
    shuffle: function (arr)
    {
        var current_index = arr.length, temp, random_index;
        while (0 != current_index)
        {
            // Pick a remaining element.
            random_index = Math.floor(Math.random() * current_index);
            current_index -= 1;

            // And swap it with the current element.
            temp = arr[current_index];
            arr[current_index] = arr[random_index];
            arr[random_index] = temp;
        }
        return arr;
    },

    //----------------------------------------------------------------------
    loadImage: function (url, resource_tracker)
    {
        var image = new Image();
        resource_tracker.add();
        image.onload = function (event) {
            resource_tracker.onload(event);
        };
        image.src = url;
        return image;
    },

    //----------------------------------------------------------------------
    loadAudio: function (url, resource_tracker)
    {
        var audio = new buzz.sound(
          url, {
          //formats: [ "wav" ],
          preload: true,
          autoplay: false,
          loop: false
        });
        resource_tracker.add();
        audio.bindOnce("canplay", function (event) {
            resource_tracker.onload(event)
        });
        return audio;
    }
};

var TextLabelWithBoundingBox = function(text, x, y, width, color, size)
{
  
  this.x = x;
  this.y = y;
  this.size = size;
  this.height = size * text.length;
  this.width = width;
  this.inner_size = (6 * this.size/7);
  this.offset = ((this.size - this.inner_size) / 2);
  this.inner_width = this.width - this.offset * 2;
  this.inner_height = this.height - this.offset * 2;
  this.color = "black"
  this.font_size = (INVERSE_PHI * size);
  this.textLabel = [];
  for (var i = 0; i < text.length; i++)
  {
    this.textLabel.push(new TextLabel(text[i], x + this.offset + this.width/2, (y + this.size * i + this.offset + this.inner_size / 2), color, HorizontalLabelAlignEnum.CENTER, VerticalLabelBaselineEnum.MIDDLE, this.font_size));
  }
  
  this.paint = function(canvas, ctx)
  {
    //var width = this.textLabel.text_size;
    var x = Math.round(this.x * canvas.height);
    var y = Math.round(this.y * canvas.height);
    var offset = Math.round(this.offset * canvas.height);
    var inner_width = Math.round(this.inner_width * canvas.height);
    var inner_height = Math.round(this.inner_height * canvas.height);
    ctx.lineJoin ="round";
    ctx.lineWidth = Math.round(this.size / (10*PHI));
    ctx.fillStyle = "#f0f0f0";
    ctx.fillRect(x + offset, y + offset, inner_width, inner_height);
    ctx.strokeStyle = this.color;
    ctx.fillStyle = this.color;
    ctx.strokeRect(x + offset, y + offset, inner_width, inner_height);
    for (var i = 0; i < this.textLabel.length; i++)
    {
      this.textLabel[i].paint(canvas, ctx);
    }
  };
  
  this.handleMouseDown = function(event)
  {
      var event_x = event.offsetX / event.currentTarget.height;
      var event_y = event.offsetY / event.currentTarget.height;
      if(event_x >= this.x &&
        event_x <= this.x + this.width &&
        event_y >= this.y &&
        event_y <= this.y + this.height)
      {
        return true;
      }
  };
}

var Grid = function()
{
  this.visible = false;
  this.size = GRID_SIZE;
  this.inner_size = 6 * this.size/7;
  this.offset = (this.size - this.inner_size) / 2;
  this.squares = [];
  this.font_width = null;
  this.font_height = null;
  this.font_center_x = null;
  this.font_center_y = null;

  this.checkPulse = function()
  {
    return true;
  };

  this.handleMouseDown = function(event)
  {
    if (this.font_width &&
      this.font_height &&
      this.font_center_x &&
      this.font_center_y)
    {
      if(event.offsetX > this.font_center_x - this.font_width / 2 &&
        event.offsetX < this.font_center_x + this.font_width / 2 &&
        event.offsetY > this.font_center_y - this.font_height / 2 &&
        event.offsetY < this.font_center_y + this.font_height / 2)
      {
        this.visible = !this.visible;
        return true;
      }
    }
    return false;
  };

  this.paint = function(canvas, ctx)
  {
    ctx.fillStyle = MOVEABLE_COLOR;
    ctx.textBaseline="middle";
    ctx.textAlign="center";
    size = this.size * canvas.height;
    this.font_height = Math.round(INVERSE_PHI * this.inner_size * canvas.height);
    ctx.font = this.font_height + "px Verdana";
    var text = "GRID: " + (this.visible ? "ON" : "OFF");
    this.font_width = ctx.measureText(text).width;
    this.font_center_x = Math.round(canvas.width / 2);
    this.font_center_y = Math.round(canvas.height - size * 2);
    ctx.fillText(text, this.font_center_x, this.font_center_y)

    if (!this.visible)
    {
      return;
    }
    ctx.fillStyle = "rgba(0,0,0,.25)"; //STATIC_COLOR;
    var offset = (canvas.height * this.offset);
    var inner_size = (this.inner_size * canvas.height);
    for(var i = this.squares.length - 1; i>=0; i--)
    {
      ctx.fillRect(Math.round(this.squares[i][0] * size + offset),
      Math.round(this.squares[i][1] * size  + offset), Math.round(inner_size), Math.round(inner_size));
    }
  };
}

var LetterBoxCollection = function()
{
  this.letterBoxList = [];
  this.alive = true;
  this.color = "#ffffff";

  this.handleTimeStep = function()
  {
  };

  this.checkPulse = function()
  {
    return this.alive;
  }

  this.handleMouseDown = function(event)
  {
    for(var i = this.letterBoxList.length - 1; i>=0; i--)
    {
      if(this.letterBoxList[i].handleMouseDown(event))
      {
        return true;
      }
    }
    return false;
  };

  this.paint = function(canvas, ctx)
  {
    for(var i = this.letterBoxList.length - 1; i>=0; i--)
    {
      this.letterBoxList[i].color = this.color;
      this.letterBoxList[i].opaque = true;
      this.letterBoxList[i].paint(canvas, ctx);
    }
  };

  this.transpose = function(deltaX, deltaY)
  {
    for(var i = this.letterBoxList.length - 1; i>=0; i--)
    {
      this.letterBoxList[i].transpose(deltaX, deltaY);
    }
  }

  this.snap = function(size)
  {
    for(var i = this.letterBoxList.length - 1; i>=0; i--)
    {
      this.letterBoxList[i].x = size * Math.round((this.letterBoxList[i].x)/size);
      this.letterBoxList[i].y = size * Math.round((this.letterBoxList[i].y)/size);
    }
  }
  
  this.offset = function()
  {
    var i = 0;
    var min_x = this.letterBoxList[i].x;
    var min_y = this.letterBoxList[i].y;
    for(i = 1; i < this.letterBoxList.length; i++)
    {
      min_x = Math.min(min_x,this.letterBoxList[i].x);
      min_y = Math.min(min_y,this.letterBoxList[i].y);
    }
    return [min_x, min_y];
  }
}

var LetterBox = function(x,y,size,letter)
{
  this.x = x;
  this.y = y;
  this.size = size;
  this.inner_size = (6 * this.size/7) * (Math.random() * (.25) + .925);
  this.offset = ((this.size - this.inner_size) / 2);
  this.letter = letter;
  this.color = MOVEABLE_COLOR; //overwritten by LetterBoxCollection
  this.alive = true;
  this.opaque = true;
  this.font = Util.randomItem(["Verdana", "Arial Black", "Times New Roman", "Impact Header", "Lucida Bright", "Georgia"]);
  this.fillStyle = Util.randomItem(["#d65955", "#90bbed", "#8ca84a", "#A597DA"]);
  this.rotation = Math.random() / 10000;
  

  this.handleTimeStep = function()
  {
  };

  this.checkPulse = function()
  {
    return this.alive;
  };

  this.handleMouseDown = function(event)
  {
    var event_x = event.offsetX / event.currentTarget.height;
    var event_y = event.offsetY / event.currentTarget.height;
    //alert("this.x = " + this.x + ", this.size = " + this.size + ", event.offsetX = " + event.offsetX);
    var hit = this.x + this.size >= event_x &&
      event_x >= this.x &&
      this.y + this.size >= event_y &&
      event_y >= this.y;
    return hit;
  };

  this.paint = function(canvas, ctx)
  {
    ctx.lineJoin ="round";
    var size = Math.round(this.size*canvas.height);
    var offset = Math.round(this.offset*canvas.height);
    var x = Math.round(this.x*canvas.height);
    var y = Math.round(this.y*canvas.height);
    var shadow_offset = Math.round(3/600 * canvas.height);
    var inner_size = Math.round(this.inner_size*canvas.height);
    ctx.lineWidth = Math.round(size / (10*PHI));
    if(this.opaque)
    {
      ctx.fillStyle = "rgba(0,0,0,.5)";
      ctx.fillRect(x + offset + shadow_offset, y + offset + shadow_offset, inner_size, inner_size);
      ctx.fillStyle = this.fillStyle;
      ctx.fillRect(x + offset, y + offset, inner_size, inner_size);


    }
    ctx.strokeStyle = "#000000";
    ctx.fillStyle = "rgba(0,0,0,.9)";
    ctx.strokeRect(x + offset, y + offset, inner_size, inner_size);
    ctx.textBaseline="middle";
    ctx.textAlign="center";
    ctx.font = Math.round(.95 * inner_size) + "px " + this.font;
    ctx.fillText(this.letter,Math.round(x+size/2),Math.round(y+size/2));
    ctx.rotate(this.rotation);
  };
  
  this.paintLevel = function()
  {
    return 1;
  };

  this.transpose = function(deltaX, deltaY)
  {
    this.x += deltaX;
    this.y += deltaY;
  }
};

var IconButton = function(icon,x,y,size)
{
  this.icon = icon;
  this.x = x;
  this.y = y;
  this.size = size;
  this.handleMouseDown = function(event)
  {
    var mouse_x = event.offsetX/event.currentTarget.height;
    var mouse_y = event.offsetY/event.currentTarget.height;
    return this.x <= mouse_x && mouse_x <= this.x + this.size &&
      this.y <= mouse_y && mouse_y <= this.y + this.size;
  };
  this.paint = function (cavnas, ctx)
  {
    var x = Math.round(this.x * canvas.height);
    var y = Math.round(this.y * canvas.height);
    var size = Math.round(this.size * canvas.height);
    ctx.drawImage(this.icon,x,y,size,size);
  };
}

var VictoryCelebration = function(jut)
{
  g_leveldone.play();
  this.jut = jut;
  this.letters = [];
  this.velocity = [0,0,0,0,0,0,0,0,0,0];
  this.bounces = [0,0,0,0,0,0,0,0,0,0];
  this.acceleration = 1/600;
  this.breakpoint = [1/2 - GRID_SIZE*2, 1/2];
  this.menu_button = null;
  this.next_button = null;
  this.bg = 0.0;
  var x = g_aspect_ratio/2;
  var y = -GRID_SIZE*4;
  y -= GRID_SIZE*2;
  x -= GRID_SIZE*2 * 2.5;
  y -= 40/600;
  this.letters.push(new LetterBox(x,y,GRID_SIZE*2,"S"));
  this.letters.push(new LetterBox(x,y+GRID_SIZE*2,GRID_SIZE*2,"C"));
  x += GRID_SIZE*2;
  y += 20/600;
  this.letters.push(new LetterBox(x,y,GRID_SIZE*2,"T"));
  this.letters.push(new LetterBox(x,y+GRID_SIZE*2,GRID_SIZE*2,"L"));
  x += GRID_SIZE*2;
  y -= 60/600;
  this.letters.push(new LetterBox(x,y,GRID_SIZE*2,"A"));
  this.letters.push(new LetterBox(x,y+GRID_SIZE*2,GRID_SIZE*2,"E"));
  x += GRID_SIZE*2;
  y += 20/600;
  this.letters.push(new LetterBox(x,y,GRID_SIZE*2,"G"));
  this.letters.push(new LetterBox(x,y+GRID_SIZE*2,GRID_SIZE*2,"A"));
  x += GRID_SIZE*2;
  y += 20/600;
  this.letters.push(new LetterBox(x,y,GRID_SIZE*2,"E"));
  this.letters.push(new LetterBox(x,y+GRID_SIZE*2,GRID_SIZE*2,"R"));
  
  levelcounts += 1;

  this.handleTimeStep = function()
  {
    if(this.bg < .75)
    {
      this.bg += 0.02;
      if(this.bg >= .75)
      {
        this.menu_button = new TextLabelWithBoundingBox(["<< MENU"], g_aspect_ratio/2 - 2.5 * GRID_SIZE*2, 1/2 + GRID_SIZE*2, GRID_SIZE*2 * 2.5, "black", GRID_SIZE);
        if(g_level < g_puzzles.length - 1)
        {
          this.next_button = new TextLabelWithBoundingBox(["NEXT >>"], g_aspect_ratio/2, 1/2 + GRID_SIZE*2, GRID_SIZE*2 * 2.5, "black", GRID_SIZE);
        }
      }
    }
    
    for(var i = 0; i < this.letters.length; ++i)
    {
      if (this.bounces[i] < 20)
      {
        this.velocity[i] += this.acceleration;
        this.letters[i].transpose(0,this.velocity[i]);
        if (this.letters[i].y > this.breakpoint[i % 2])
        {
          this.letters[i].y = this.breakpoint[i % 2];
          this.bounces[i]++;
          this.velocity[i] = -0.5 * this.velocity[i];
        }
      }
    }
  };
  
  this.handleMouseDown = function(event)
  {
    if(this.menu_button && this.menu_button.handleMouseDown(event))
    {
      this.jut.switchToScreen(MenuScreen);
      return;
    }
    if(this.next_button && this.next_button.handleMouseDown(event))
    {
      g_level++;
      if(g_level > g_puzzles.length)
      {
        g_level--;
        return;
      }
      this.jut.switchToScreen(GameScreen);
      return;
    }
  }

  this.paint = function(canvas, ctx)
  {
    ctx.fillStyle = "rgba(240, 240, 240, " + this.bg + ")";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    for(var i = 0; i < this.letters.length; ++i)
    {
      this.letters[i].opaque = true;
      this.letters[i].paint(canvas, ctx);
    }
    if (this.menu_button)
    {
      this.menu_button.paint(canvas, ctx);
    }
    if (this.next_button)
    {
      this.next_button.paint(canvas, ctx);
    }
  };

  this.checkPulse = function(ctx)
  {
    return true;
  }
};

var VerticalLabelBaselineEnum = {
  TOP: 0,
  MIDDLE: 1,
  BOTTOM: 2,
  properties: {
    0: { textBaseline: "top" },
    1: { textBaseline: "middle" },
    2: { textBaseline: "bottom" },
  }
};


var HorizontalLabelAlignEnum = {
  LEFT: 0,
  CENTER: 1,
  RIGHT: 2,
  properties: {
    0: { textAlign: "left" },
    1: { textAlign: "center" },
    2: { textAlign: "right" },
  }
};

var TextLabel = function(text, x, y, color, alignment, baseline, size)
{
  this.size = size;
  this.alignment = alignment;
  this.baseline = baseline;
  this.x = x;
  this.y = y;
  this.text_size = 0;
  this.color = color;
  this.text = text;
  
  this.handleMouseDown = function (event)
  {
    var event_x = event.offsetX / event.currentTarget.height;
    var event_y = event.offsetY / event.currentTarget.height;
    switch (this.alignment)
    {
      case HorizontalLabelAlignEnum.LEFT:
        if (event_x < this.x || event_x > this.x + this.text_size)
        {
          return false;
        }
        break;
      case HorizontalLabelAlignEnum.RIGHT:
        if (event_x < this.x - this.text_size || event_x > this.x)
        {
          return false;
        }
        break;
      case HorizontalLabelAlignEnum.CENTER:
        if (event_x < this.x - this.text_size / 2 || event_x > this.x + this.text_size / 2)
        {
          return false;
        }
        break;
      default:
        return false;
    }
    
    switch (this.baseline)
    {
      case VerticalLabelBaselineEnum.TOP:
        if (event_y < this.y || event_y > this.y + this.size)
        {
          return false;
        }
        break;
      case VerticalLabelBaselineEnum.BOTTOM:
        if (event_y < this.y - this.size || event_y > this.y)
        {
          return false;
        }
        break;
      case VerticalLabelBaselineEnum.MIDDLE:
        if (event_y < this.y - this.size / 2 || event_y > this.y + this.size / 2)
        {
          return false;
        }
        break;
      default:
        return false;
    }
    
    return true;
  },
  
  this.paint = function(canvas, ctx)
  {
    var size = this.size * canvas.height;
    var x = this.x * canvas.height;
    var y = this.y * canvas.height;
    ctx.font = Math.round(size) + "px Verdana";
    this.text_size = ctx.measureText(this.text).width / canvas.height;
    ctx.textAlign = HorizontalLabelAlignEnum.properties[this.alignment].textAlign;
    ctx.textBaseline = VerticalLabelBaselineEnum.properties[this.baseline].textBaseline;
    ctx.fillStyle = this.color;
    ctx.fillText(this.text, x, y);
  }
};

var Timer = function(timer, callback, parameter)
{
  this.current_time = timer;
  this.callback = callback;
  this.parameter = parameter;
  this.handleTimeStep = function()
  {
    this.current_time--;
    if(this.current_time <= 0)
    {
      callback(this.parameter);
    }

  };
  this.checkPulse = function(){
        return this.current_time > 0;
  };
};
    
var MouseButtonEnum = {
  NONE: 0,
  LEFT: 1,
  RIGHT: 2,
  BOTH: 3,
  properties: {
    random: function() { return Math.floor(Math.random() * 4); }
  }
};
    
var TutorialScreen = {
  init: function (jut) {
    this.jut = jut;
    this.reset();
  },
  reset: function () {
    this.mouse_instructions = []
    this.mouse_instructions.push([3,["Welcome to Crossword Puzzles!","Reassemble the pieces into a crossword puzzle","in order to solve each level","Each word in the completed puzzle is","related to that puzzle's title"]]);
    this.mouse_instructions.push([4]);
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([4])
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([4])
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([4])
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([4])
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([4])
    this.mouse_instructions.push([2,5]);
    this.mouse_instructions.push([3,["This puzzle's title is","\"THE NAME OF THE GAME\"","What could that mean?","You can drag tiles together with left click"]]);
    this.mouse_instructions.push([0, 6*GRID_SIZE + GRID_SIZE/2, 5*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([1,MouseButtonEnum.LEFT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([0, 15*GRID_SIZE + GRID_SIZE/2, 10*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0, 13*GRID_SIZE + GRID_SIZE/2, 8*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([3,["You can drag connected groups with right click"]]);
    /*
    */
    this.mouse_instructions.push([0, 17*GRID_SIZE + GRID_SIZE/2, 10*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([1,MouseButtonEnum.RIGHT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([0, 13*GRID_SIZE + GRID_SIZE/2, 7*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0, 11*GRID_SIZE + GRID_SIZE/2, 9*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([3,["You can toggle the grid showing the shape of the","completed puzzle on and off"]]);
    this.mouse_instructions.push([0,g_aspect_ratio / 2,1 - GRID_SIZE*2]);
    this.mouse_instructions.push([1,MouseButtonEnum.LEFT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0,g_aspect_ratio / 2,1 - GRID_SIZE*4]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([0,g_aspect_ratio / 2,1 - GRID_SIZE*2]);
    this.mouse_instructions.push([1,MouseButtonEnum.LEFT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0,g_aspect_ratio / 2, 1 - GRID_SIZE*4]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([3,["Reassemble all the words to complete the puzzle!"]]);
    this.mouse_instructions.push([0, 5*GRID_SIZE + GRID_SIZE/2, 11*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.LEFT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([0, 13*GRID_SIZE + GRID_SIZE/2, 9*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0, 18*GRID_SIZE + GRID_SIZE/2, 6*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.LEFT]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([0, 9*GRID_SIZE + GRID_SIZE/2, 9*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,20]);
    this.mouse_instructions.push([1,MouseButtonEnum.NONE]);
    this.mouse_instructions.push([0, 6*GRID_SIZE + GRID_SIZE/2, 6*GRID_SIZE + GRID_SIZE/2]);
    this.mouse_instructions.push([2,50]);
    this.mouse_x = g_aspect_ratio/ 2;
    this.mouse_y = 1/ 2;
    this.mouse_buttons = MouseButtonEnum.NONE;

    this.mouseSpeed = 10/600;
    this.idle_timer = 0;
    this.gameScreen = GameScreen;
    this.gameScreen.reset();
    this.gameScreen.name = "THE NAME OF THE GAME";
    this.detective = null;
    /*var temp_level = g_level;
    g_level = g_puzzles.length;
    this.gameScreen.reset();
    
    this.gameScreen.loadLevel({"pieces":[{"str":["PUZZ"],"x":16,"y":6,"vx":7,"vy":9},{"str":["WO"],"x":6,"y":5,"vx":11,"vy":7},{"str":["LES","..S"],"x":3,"y":11,"vx":11,"vy":9},{"str":["C.","RD","O."],"x":17,"y":9,"vx":13,"vy":6}],"grid":{"str":["......O.","....OOOO","......O.","OOOOOOO.","......O."],"x":7,"y":6},"name":"THE NAME OF THE GAME"});
    g_level = temp_level;
    */
  },
  handleMouseDown: function (event) {
    if (!this.gameScreen.solved && this.gameScreen.backTextSize &&
      this.gameScreen.textHeight)
    {
      if(event.offsetY > event.currentTarget.height - this.gameScreen.textHeight)
      {
        if(event.offsetX < this.gameScreen.backTextSize)
        {
          this.jut.switchToScreen(MenuScreen);
          return true;
        }
      }
    }
    if (this.mouse_instructions.length === 0)
    {
      this.gameScreen.handleMouseDown(event);
      return;
    }
    var current_instruction = this.mouse_instructions[0];
    if (current_instruction[0] === 3)
    {
      this.idle_timer = 0;
      this.detective.handleMouseDown(event);
    }
  },
  handleTimeStep: function () {
    if (!this.canvas)
    {
      return;
    }
    var canvas = this.canvas;
    if (this.mouse_instructions.length === 0)
    {
      this.gameScreen.handleTimeStep();
      return;
    }
    
    var current_instruction = this.mouse_instructions[0];
    var current_instruction_done = true;
    if (current_instruction[0] === 0)
    {
      var dy = this.mouse_y - current_instruction[2];
      var dx = this.mouse_x - current_instruction[1];
      if (Math.abs(dy) < this.mouseSpeed)
      {
        this.mouse_y = current_instruction[2];
      }
      else if(dy < 0)
      {
        this.mouse_y += this.mouseSpeed;
        current_instruction_done = false;
      }
      else if(dy > 0)
      {
        this.mouse_y -= this.mouseSpeed;
        current_instruction_done = false;
      }
      
      if (Math.abs(dx) < this.mouseSpeed)
      {
        this.mouse_x = current_instruction[1];
      }
      else if(dx < 0)
      {
        this.mouse_x += this.mouseSpeed;
        current_instruction_done = false;
      }
      else if(dx > 0)
      {
        this.mouse_x -= this.mouseSpeed;
        current_instruction_done = false;
      }
      this.gameScreen.handleMouseMove(
        {offsetX: this.mouse_x * canvas.height, offsetY: this.mouse_y * canvas.height,
        currentTarget : {height : canvas.height}});
    }
    
    if (current_instruction[0] === 1)
    {
      var old_buttons = this.mouse_buttons;
      this.mouse_buttons = current_instruction[1];
      if ((old_buttons === MouseButtonEnum.NONE || old_buttons === MouseButtonEnum.RIGHT) &&
        (this.mouse_buttons === MouseButtonEnum.LEFT || this.mouse_buttons === MouseButtonEnum.BOTH))
      {
        this.gameScreen.handleMouseDown({button: 0, offsetX: this.mouse_x * canvas.height, offsetY: this.mouse_y * canvas.height,
        currentTarget : {height : canvas.height}});
      }
      if ((old_buttons === MouseButtonEnum.NONE || old_buttons === MouseButtonEnum.LEFT) &&
        (this.mouse_buttons === MouseButtonEnum.RIGHT || this.mouse_buttons === MouseButtonEnum.BOTH))
      {
        this.gameScreen.handleMouseDown({button: 2, offsetX: this.mouse_x * canvas.height, offsetY: this.mouse_y * canvas.height,
        currentTarget : {height : canvas.height}});
      }
      if ((old_buttons === MouseButtonEnum.BOTH || old_buttons === MouseButtonEnum.RIGHT) &&
        (this.mouse_buttons === MouseButtonEnum.LEFT || this.mouse_buttons === MouseButtonEnum.NONE))
      {
        this.gameScreen.handleMouseUp({button: 2, offsetX: this.mouse_x * canvas.height, offsetY: this.mouse_y * canvas.height,
        currentTarget : {height : canvas.height}});
      }
      if ((old_buttons === MouseButtonEnum.BOTH || old_buttons === MouseButtonEnum.LEFT) &&
        (this.mouse_buttons === MouseButtonEnum.RIGHT || this.mouse_buttons === MouseButtonEnum.NONE))
      {
        this.gameScreen.handleMouseUp({button: 0, offsetX: this.mouse_x * canvas.height, offsetY: this.mouse_y * canvas.height,
        currentTarget : {height : canvas.height}});
      }
    }
    
    if (current_instruction[0] === 2)
    {
      this.idle_timer++;
      if (this.idle_timer < current_instruction[1])
      {
        current_instruction_done = false;
      }
    }
    
    if (current_instruction[0] === 3)
    {
      if (this.detective === null)
      {
        this.detective = createDetective(current_instruction[1]);
        /*
        new TextLabelWithBoundingBox(current_instruction[1], g_aspect_ratio/2 - GRID_SIZE*10, 1/2 - current_instruction[1].length/2 * GRID_SIZE, GRID_SIZE*20, "black", GRID_SIZE);
        */
      }
      this.detective.handleTimeStep();
      current_instruction_done = !this.detective.active();
    }
    
    if (current_instruction[0] === 4)
    {
      if (this.gameScreen.name_color === "black")
      {
        this.gameScreen.name_color = "gray";
      }
      else
      {
        this.gameScreen.name_color = "black";
      }
    }
    
    if (current_instruction_done)
    {
      this.mouse_instructions.splice(0,1);
      this.idle_timer = 0;
      this.detective = null;
    }
  },
  
  paint: function (canvas, ctx) {
    this.canvas = canvas;
    this.gameScreen.paint( canvas, ctx);
    if (this.mouse_instructions.length > 0)
    {
      this.drawMouse(canvas, ctx, this.mouse_x, this.mouse_y, this.mouse_buttons);
    }
    if (this.detective)
    {
    /*
      ctx.fillStyle = "rgba(240, 240, 240, .75)";
      ctx.fillRect(
        0, 0,
        canvas.width,
        canvas.height);
        */
      ctx.globalAlpha=.95;
      ctx.drawImage(g_bg,0,0,1600,1200,0,0,g_aspect_ratio*canvas.height,1*canvas.height);
      ctx.globalAlpha=1;
      this.detective.paint(canvas, ctx);
    }
  },

  drawMouse: function (canvas, ctx,centerX, centerY, mouseButton) {
    var offset = 2/35 * GRID_SIZE * canvas.height;
    var radius = 12/35 * GRID_SIZE * canvas.height;
    centerX = centerX * canvas.height;
    centerY = centerY * canvas.height;
    var border = offset/2;
    var left_color = "grey";
    var right_color = "grey";
    if(mouseButton === MouseButtonEnum.LEFT || mouseButton === MouseButtonEnum.BOTH)
    {
      left_color = "black";
    }
    if(mouseButton === MouseButtonEnum.RIGHT || mouseButton === MouseButtonEnum.BOTH)
    {
      right_color = "black";
    }
    this.drawWedge(ctx, right_color, centerX + border, centerY - border, radius, 3 * Math.PI / 2, 0);
    this.drawWedge(ctx, left_color, centerX - border, centerY - border, radius, Math.PI, 3 * Math.PI / 2);
    var width = (offset + 2 * radius);
    var height = 8/35 * GRID_SIZE * canvas.height;
    ctx.fillStyle = "gray";
    ctx.beginPath();
    ctx.moveTo(centerX - width/2 + width, centerY + border);
    ctx.lineTo(centerX - width/2 + width, centerY + border + height);
    //this.drawWedge(ctx, "gray", centerX, centerY + border + height, radius + border, 0, Math.PI);
    ctx.arc(centerX, centerY + border + height, radius + border, 0, Math.PI);
    ctx.lineTo(centerX - width/2, centerY + border);
    ctx.closePath();
    ctx.fill();
  },

  drawWedge: function(ctx, color, centerX, centerY, radius, startAngle, endAngle)
  {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(centerX,centerY);
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
    ctx.closePath();
    ctx.fill();
  }
};

//##########################################################################
var MenuScreen = {
  init: function (jut) {
    this.jut = jut;
    this.current_page = 0;
    this.reset();
  },
  reset: function () {
    this.static_labels = [];
    this.levels_per_page = 7;
    this.pages = Math.floor(g_puzzles.length / this.levels_per_page);
    if (g_puzzles.length % this.levels_per_page !== 0)
    {
      this.pages++;
    }
    this.loadLevelLabels();
    var width = g_aspect_ratio;
    var height = 1;
    var y = height/2;
    this.static_labels.push(new TextLabel("LEVEL SELECT", width/2, (y + 26/35 * GRID_SIZE * -5),
        "black", HorizontalLabelAlignEnum.CENTER, VerticalLabelBaselineEnum.MIDDLE, (INVERSE_PHI * 26/35 * GRID_SIZE)));
    this.page_left = new TextLabel("<<", 0, height, "gray", HorizontalLabelAlignEnum.LEFT, VerticalLabelBaselineEnum.BOTTOM, (INVERSE_PHI * 26/35 * GRID_SIZE));
    this.page_right = new TextLabel(">>", width, height, "gray", HorizontalLabelAlignEnum.RIGHT, VerticalLabelBaselineEnum.BOTTOM, (INVERSE_PHI * 26/35 * GRID_SIZE));
    this.sound_button = new IconButton(g_muted ? g_muted_icon : g_unmuted_icon, width - (INVERSE_PHI * 26/35 * GRID_SIZE * 2), 0, (INVERSE_PHI * 26/35 * GRID_SIZE * 2));
  },
  loadLevelLabels: function () {
    this.level_labels = [];
    var y = 1/2;
    var width = g_aspect_ratio;
    var offset = this.current_page * this.levels_per_page;
    for (var i = 0; i + offset < g_puzzles.length && i < this.levels_per_page; i++)
    {
      var level_name = g_puzzles[i + offset].name;
      if ((i + offset)>levelcounts) {
        level_name = "??????"
      }
      this.level_labels.push(new TextLabel(level_name, width/2, ((i - 3) * 26/35 * GRID_SIZE + y),
        "gray", HorizontalLabelAlignEnum.CENTER, VerticalLabelBaselineEnum.MIDDLE, (INVERSE_PHI * 26/35 * GRID_SIZE)));
    }
    this.page_display = new TextLabel("PAGE " + (this.current_page+1) + "/" + this.pages, width/2, (y + 26/35 * GRID_SIZE * 5),
      "black", HorizontalLabelAlignEnum.CENTER, VerticalLabelBaselineEnum.MIDDLE, (INVERSE_PHI * 26/35 * GRID_SIZE));
  },
  handleMouseDown: function (event) {
    for (var i = 0; i < this.level_labels.length; i++)
    {
        if((i + this.current_page * this.levels_per_page)<= levelcounts) {
          if(this.level_labels[i].handleMouseDown(event))
          {
            g_level = i + this.current_page * this.levels_per_page;
            if (g_level === 0)
            {
              this.jut.switchToScreen(TutorialScreen);
              return;
            }
            this.jut.switchToScreen(GameScreen);
            return;
          }
      }
    }
    if(this.page_left.handleMouseDown(event))
    {
      if(this.current_page > 0)
      {
        this.current_page--;
        this.loadLevelLabels();
      }
    }
    if(this.page_right.handleMouseDown(event))
    {
      if(this.current_page < this.pages - 1)
      {
        this.current_page++;
        this.loadLevelLabels();
      }
    }
    if(this.sound_button.handleMouseDown(event))
    {
      g_muted = !g_muted;
      this.sound_button.icon = g_muted ? g_muted_icon : g_unmuted_icon;
      if (g_muted)
      {
        g_mainloop.stop();
      }
      else
      {
        g_mainloop.setVolume(50).loop().play();
      }
    }
    
  },
  handleMouseMove: function (event) {
    for (var i = 0; i < this.level_labels.length; i++)
    {
      if(this.level_labels[i].handleMouseDown(event))
      {
        this.level_labels[i].color = "black";
      }
      else
      {
        this.level_labels[i].color = "gray";
      }
    }
    if(this.page_left.handleMouseDown(event))
    {
      this.page_left.color = "black";
    }
    else
    {
      this.page_left.color = "gray";
    }
    if(this.page_right.handleMouseDown(event))
    {
      this.page_right.color = "black";
    }
    else
    {
      this.page_right.color = "gray";
    }
  },
  handleTimeStep: function () {
  },
  
  paint: function (canvas, ctx) {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
/*
    ctx.fillStyle = "#f0f0f0";
    ctx.fillRect(
        0, 0,
        canvas.width,
        canvas.height);
        */
    ctx.drawImage(g_bg,0,0,1600,1200,0,0,g_aspect_ratio*canvas.height,1*canvas.height);
    for (var i = 0; i < this.level_labels.length; i++)
    {
      this.level_labels[i].paint( canvas, ctx);
    }
    for (var i = 0; i < this.static_labels.length; i++)
    {
      this.static_labels[i].paint( canvas, ctx);
    }
    this.page_display.paint( canvas, ctx);
    if (this.current_page > 0)
    {
      this.page_left.paint( canvas, ctx);
    }
    if(this.current_page < this.pages - 1)
    {
      this.page_right.paint( canvas, ctx);
    }
    this.sound_button.paint( canvas, ctx);
  }
};

//##########################################################################
var GameScreen = {

    init: function (jut) {
      this.jut = jut;
      this.reset();
    },

    makePiece: function (letters, x = 0, y = 0) {
      var letter_box_collection = new LetterBoxCollection();
      var defaultX = 0;
      var defaultY = 0;
      if ( x === 0 && y === 0)
      {
        defaultX = Math.round(Math.random()*(g_aspect_ratio - GRID_SIZE*4)) + GRID_SIZE*2;
        defaultY = Math.round(Math.random()*(1 - GRID_SIZE*4)) + GRID_SIZE*2;
      }
      for (var i = 0; i < letters.length; i++)
      {
        for (var j = 0; j < letters[i].length; j++)
        {
          if (letters[i].charAt(j) !== " " && letters[i].charAt(j) !== ".")
          {
            var coord_x = (defaultX + GRID_SIZE * (j + x));
            var coord_y = (defaultY + GRID_SIZE * (i + y));
            letter_box_collection.letterBoxList.push(
              new LetterBox(coord_x, coord_y, GRID_SIZE, letters[i].charAt(j)));
          }
        }
      }
      letter_box_collection.snap(GRID_SIZE);
      this.paint_list.push(letter_box_collection);
      this.draggable_list.push(letter_box_collection);
      this.name_color = "black";
    },

    makeGrid: function (lines, offsetX, offsetY) {
      var grid = new Grid();
      for (var i = 0; i < lines.length; i++)
      {
        for (var j = 0; j < lines[i].length; j++)
        {
          if (lines[i].charAt(j) !== " " && lines[i].charAt(j) !== ".")
          {
            grid.squares.push([j + offsetX, i + offsetY]);
          }
        }
      }
      this.paint_list.push(grid);
      this.clickable_list.push(grid);
    },

    loadLevel: function (stage)
    {
      for(var i = 0; i < stage.pieces.length; i++)
      {
        this.makePiece(stage.pieces[i].str,
          stage.pieces[i].x,
          stage.pieces[i].y
        );
      }
      this.makeGrid(stage.grid.str,
        stage.grid.x,
        stage.grid.y
      );
      this.name = stage.name;
    },
    
    populateLevel: function (stage)
    {
      if (stage < g_puzzles.length)
      {
        
        this.loadLevel(g_puzzles[stage]);
        
        //alert(JSON.stringify(g_puzzles));
        //alert(decodeURIComponent(encodeURIComponent(JSON.stringify(g_puzzles[stage]))));
        return;
      }
      else
      {
        this.name = "INVALID PUZZLE";
      }
    },
    
    checkAdjancent: function(tileSet1, tileSet2)
    {
      for(var j = 0; j < tileSet1.letterBoxList.length; j++)
      {
        for(var k = 0; k < tileSet2.letterBoxList.length; k++)
        {
          var distance = Math.abs(tileSet1.letterBoxList[j].x - tileSet2.letterBoxList[k].x) +
            Math.abs(tileSet1.letterBoxList[j].y - tileSet2.letterBoxList[k].y);
          if (GRID_SIZE*.95 < distance && distance < GRID_SIZE*1.05)
          {
            return true;
          }
        }
      }
      return false;
    },
    
    checkOnScreen: function(tileSet)
    {
      for(var j = 0; j < tileSet.letterBoxList.length; j++)
      {
        if (tileSet.letterBoxList[j].x < g_aspect_ratio &&
          tileSet.letterBoxList[j].y < 1 &&
          tileSet.letterBoxList[j].x > 0 &&
          tileSet.letterBoxList[j].y > 0)
        {
          return true;
        }
      }
      return false;
    },
    
    returnToScreen: function(tileSet)
    {
      for(var j = 0; j < tileSet.letterBoxList.length; j++)
      {
        while(tileSet.letterBoxList[j].x < 0)
        {
          tileSet.transpose(GRID_SIZE,0);
        }
        while(tileSet.letterBoxList[j].y < 0)
        {
          tileSet.transpose(0, GRID_SIZE);
        }
        while(tileSet.letterBoxList[j].x > g_aspect_ratio)
        {
          tileSet.transpose(-GRID_SIZE, 0);
        }
        while(tileSet.letterBoxList[j].y > 1)
        {
          tileSet.transpose(0, -GRID_SIZE);
        }
      }
    },
    
    findOffscreenAdjacentTileSets : function()
    {
      var adjacencySet = Array(this.draggable_list.length).fill(false);
      
      var unexpanded;
      var returnSet;
      var needs_recentering;
      for(var j = 0; j < adjacencySet.length; j++)
      {
        if(adjacencySet[j])
        {
          continue;
        }
        
        returnSet = [];
        needs_recentering = true;
        adjacencySet[j] = true;
        unexpanded = [this.draggable_list[j]];
        while(unexpanded.length > 0)
        {
          var tileSet = unexpanded.pop();
          returnSet.push(tileSet);
          needs_recentering = needs_recentering && !this.checkOnScreen(tileSet)
          for(var i = this.draggable_list.length - 1; i>=0; i--)
          {
            if (!adjacencySet[i])
            {
              if (this.checkAdjancent(tileSet,this.draggable_list[i]))
              {
                adjacencySet[i] = true;
                unexpanded.push(this.draggable_list[i]);
              }
            }
          }
        }
        if(needs_recentering)
        {
          //alert(returnSet.length + " tiles lost");
          for(var i = 0; i < returnSet.length; ++i)
          {
            this.returnToScreen(returnSet[i]);
          }
        }
      }
      return;
    },

    findAdjacentTileSets: function(draggable_list_item_index)
    {
      var adjacencySet = Array(this.draggable_list.length).fill(false);
      adjacencySet[draggable_list_item_index] = true;
      var returnSet = [];
      var unexpanded = [ this.draggable_list[draggable_list_item_index] ];
      while(unexpanded.length > 0)
      {
        var tileSet = unexpanded.pop();
        returnSet.push(tileSet);
        for(var i = this.draggable_list.length - 1; i>=0; i--)
        {
          if (!adjacencySet[i])
          {
            if (this.checkAdjancent(tileSet,this.draggable_list[i]))
            {
              adjacencySet[i] = true;
              unexpanded.push(this.draggable_list[i]);
            }
          }
        }
      }
      return returnSet;
    },
    
    reset: function () {
      this.paint_list = [];
      this.timestep_list = [];
      this.draggable_list = [];
      this.clickable_list = [];
      this.dragged_item_collection = null;
      this.mouse_pos = [null, null];
      this.name = "";
      this.backTextSize = null;
      this.textHeight = null;
      this.solved = false;

      this.populateLevel(g_level);

      /*
      for (var i = 0; i < canvas.width; i += GRID_SIZE)
      {
        var box = new LetterBox(i, 0, GRID_SIZE, "0123456789".charAt((i / GRID_SIZE) % 10));
        box.color = STATIC_COLOR;
        this.paint_list.push(box);
      }
      for (var i = GRID_SIZE; i < canvas.height; i += GRID_SIZE)
      {
        var box = new LetterBox(0, i, GRID_SIZE, "0123456789".charAt((i / GRID_SIZE) % 10));
        box.color = STATIC_COLOR;
        this.paint_list.push(box);
      }
      //*/
    },
    
    checkForSolved: function () {
      if (this.solved)
      {
        return;
      }
      var dx;
      var dy;
      var dim;
      for (var i = 0; i < this.draggable_list.length; ++i)
      {
        dim = this.draggable_list[i].offset();
        if (i === 0)
        {
          dx = g_puzzles[g_level].pieces[i].vx - Math.round(dim[0]/GRID_SIZE);
          dy = g_puzzles[g_level].pieces[i].vy - Math.round(dim[1]/GRID_SIZE);
        }
        else
        {
          if(dx !== g_puzzles[g_level].pieces[i].vx - Math.round(dim[0]/GRID_SIZE) ||
          dy !== g_puzzles[g_level].pieces[i].vy - Math.round(dim[1]/GRID_SIZE))
          {
            return;
          }
        }
      }
      this.solved = true;
      this.draggable_list = [];
      this.clickable_list = [];
      var victory = new VictoryCelebration(this.jut);
      this.paint_list.unshift(victory);
      this.timestep_list.unshift(victory);
      this.clickable_list.push(victory);
      
      g_completed[g_level] = true;
    },
    
    handleMouseDown: function (event) {
      for(var i = this.draggable_list.length - 1; i>=0; i--)
      {
        if(!this.draggable_list[i].checkPulse())
        {
          this.draggable_list.splice(i,1);
        }
        else
        {
          if(this.draggable_list[i].handleMouseDown(event))
          {
            if(event.button == 0)
            {
              //this.draggable_list[i].color = MOVE_COLOR;
              this.dragged_item_collection = [ this.draggable_list[i] ];
              g_click.stop();
              g_click.play();
            }
            else if(event.button == 2)
            {
              //this.draggable_list[i].color = MOVE_COLOR;
              this.dragged_item_collection = this.findAdjacentTileSets(i);
              g_click.stop();
              g_click.play();
            }
            return true;
          }
        }
      }
      for(var i = this.clickable_list.length - 1; i>=0; i--)
      {
        if(!this.clickable_list[i].checkPulse())
        {
          this.clickable_list.splice(i,1);
        }
        else
        {
          if(this.clickable_list[i].handleMouseDown(event))
          {
            return true;
          }
        }
      }

      if (!this.solved && this.backTextSize &&
        this.textHeight)
      {
        if(event.offsetY > event.currentTarget.height - this.textHeight)
        {
          if(event.offsetX < this.backTextSize)
          {
            this.jut.switchToScreen(MenuScreen);
            return true;
          }
        }
      }
      return false;
    },
    
    handleMouseMove: function (event) {
      var old_x = this.mouse_pos[0];
      var old_y = this.mouse_pos[1];
      var i = 0;
      this.mouse_pos[0] = event.offsetX/event.currentTarget.height;
      this.mouse_pos[1] = event.offsetY/event.currentTarget.height;
      if (this.dragged_item_collection)
      {
        for(i = 0; i < this.dragged_item_collection.length; i++)
        {
          this.dragged_item_collection[i].transpose((this.mouse_pos[0] - old_x),
            (this.mouse_pos[1] - old_y));
        }
      }
    },
    handleMouseUp: function (event) {
      if (this.dragged_item_collection)
      {
        for(i = 0; i < this.dragged_item_collection.length; i++)
        {
          //this.dragged_item_collection[i].color = MOVEABLE_COLOR;
          this.dragged_item_collection[i].snap(GRID_SIZE);
          g_click.stop();
          g_click.play();
        }
        this.checkForSolved();
        this.findOffscreenAdjacentTileSets();
      }
      this.dragged_item_collection = null;
    },
    handleTimeStep: function () {
      for(var i = this.timestep_list.length - 1; i>=0; i--)
      {
        if(!this.timestep_list[i].checkPulse())
        {
          this.timestep_list.splice(i,1);
        }
        else
        {
          this.timestep_list[i].handleTimeStep();
        }
      }
    },
    paint: function (canvas, ctx) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);

      ctx.fillStyle = "#f0f0f0";
      ctx.fillRect(
          0, 0,
          canvas.width,
          canvas.height);
      ctx.drawImage(g_bg,0,0,1600,1200,0,0,g_aspect_ratio*canvas.height,1*canvas.height);
      
      ctx.fillStyle = this.name_color;
      ctx.textBaseline="middle";
      ctx.textAlign="center";
      this.textHeight = Math.round(INVERSE_PHI * (GRID_SIZE - GRID_SIZE/7) * canvas.height);
      ctx.font = this.textHeight + "px Verdana";
      ctx.fillText(this.name,Math.round(canvas.width/2),Math.round(GRID_SIZE*2*canvas.height));
      ctx.textBaseline = "bottom";
      ctx.textAlign = "left"
      ctx.fillStyle = "black";
      this.backTextSize = ctx.measureText("<< MENU").width;
      ctx.fillText("<< MENU", 0, canvas.height);

      for (var i = this.paint_list.length - 1; i>=0; i--)
      {
        if(!this.paint_list[i].checkPulse())
        {
          this.paint_list.splice(i,1);
        }
        else
        {
          this.paint_list[i].paint( canvas, ctx);
        }
      }
    }
};

var IntroScreen = createScreen(
function() {
  var gamestate = this.gamestate;

  
  var bg = createImage(g_bg,0,0,1600,1200,0,0,g_aspect_ratio,1)
  bg.paint_level = PAINT_LEVEL.BG;
  gamestate.gameEntities.push(bg);
  
  
  //face
  var script = createScriptedEvent();
  var detective = createDetective(["Hello Detective!", "I need your help!"]);
  script.push(detective);
  var letter = createLetter(["DETECTIVE,", "I HAVE CRAFTED A MOST", "AMUSING GAME FOR US", "TO PLAY TOGETHER", "", "SINCERELY" ,"YOUR NEMESIS," ,"            DR X WORD"]);
  script.push(letter);
  
  script.push(createInstantEvent(function(gamestate){
    gamestate.jut.switchToScreen(MenuScreen);
  }
  ));
  
  script.start(gamestate);
});

//##########################################################################

//--------------------------------------------------------------------------
var ResourceTracker = {
  m_added: 1, // I track myself loading
  m_loaded: 0,
  m_ready : false,
  
  init: function (jut)
  {
    this.jut = jut;
    this.onload(null); //and here I'm loaded
  },

  handleMouseDown: function ()
  {
    if (m_ready)
    {
      m_ready = false;
      g_mainloop.loop();
      g_mainloop.play().setVolume(0).fadeTo(50,10000);
      this.jut.switchToScreen(IntroScreen);
    }
  },

  handleTimeStep: function ()
  {
    if (this.m_loaded == this.m_added)
    {
      this.onAllLoaded();
    }
  },

  paint: function (canvas, ctx)
  {
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // paint the background
    ctx.fillStyle = "#f0f0f0";
    ctx.fillRect(
      0, 0,
      canvas.width,
      canvas.height);

    ctx.font="Bold 80px Arial";
    ctx.fillStyle = "rgb(0, 0, 0)";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(
      Math.floor(100 * this.m_loaded / this.m_added) + "%",
      canvas.width / 2,
      canvas.height / 2
    );
    if (100 === Math.floor(100 * this.m_loaded / this.m_added))
    {
      ctx.font="20px Arial";
      ctx.fillText(
        "click to continue",
        canvas.width / 2,
        canvas.height / 2 + 40
      );
    }
  },


  //----------------------------------------------------------------------
  add: function ()
  {
      ++this.m_added;
  },

  //----------------------------------------------------------------------
  // from Image.onload
  onload: function (event)
  {
    ++this.m_loaded;
    if (this.m_loaded == this.m_added)
    {
      this.onAllLoaded();
    }
  },

  //----------------------------------------------------------------------
  onAllLoaded: function ()
  {
    m_ready = true;
  }
};

//--------------------------------------------------------------------------
var AudioComponents = {
};

//--------------------------------------------------------------------------
var GraphicComponents = {
};

//##########################################################################
// game engine

//--------------------------------------------------------------------------
function init()
{
  g_level = 0;
  g_completed = [];
  for (var i = 0; i < g_puzzles.length; i++)
  {
    g_completed.push(false);
  }

  var jut = createJutGameEngine(document.getElementById("canvas"));

  g_mainloop = Util.loadAudio("assets/mainloop.wav", ResourceTracker);
  g_click = Util.loadAudio("assets/click.wav", ResourceTracker);
  g_leveldone = Util.loadAudio("assets/leveldone.wav", ResourceTracker);
  g_settings = Util.loadImage("assets/round_settings_black_48dp.png", ResourceTracker);
  g_muted_icon = Util.loadImage("assets/baseline_volume_off_black_48dp.png", ResourceTracker);
  g_unmuted_icon = Util.loadImage("assets/baseline_volume_up_black_48dp.png", ResourceTracker);
  g_poirot = Util.loadImage("assets/poirot bg.png", ResourceTracker);
  g_stache = Util.loadImage("assets/stache.png", ResourceTracker);
  g_bg = Util.loadImage("assets/papelIGuess.jpeg", ResourceTracker);
  // can't do this until you've set up canvas_width and canvas_height
  //ResourceTracker init must be called after all requests to
  //loadImage/loadAudio
  ResourceTracker.init(jut);
  GameScreen.init(jut);
  TutorialScreen.init(jut);
  MenuScreen.init(jut);
  IntroScreen.init(jut);
  
  jut.setMaintainAspectRatioMode(g_aspect_ratio);
  jut.addTitleScreen(ResourceTracker);
  jut.init();
    
}

// launch the game once the document is fully loaded
window.addEventListener("load", init);

</script>
</body>
</html>
